<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>RegExp 原型属性 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters05/index.html" class="breadcrumb-item">第五章 正则的扩展</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters05/prototype-attribute.html" class="breadcrumb-item">RegExp 原型属性</a></div><h1 class="article-title">RegExp 原型属性</h1><div class="article"><h2 id="dotall-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll" target="_blank" rel="noopener">dotAll 属性</a> <a class="markdownIt-Anchor" href="#dotall-属性">#</a></h2><h3 id="基础说明">基础说明 <a class="markdownIt-Anchor" href="#基础说明">#</a></h3><p><code>RegExp.prototype.dotAll</code></p><p>返回值为一个<code>布尔值</code>，表示该<code>正则表达式</code>是否处在<code>dotAll</code>模式。</p><p>如果使用了<code>s</code>修饰符，将返回<code>Boolean</code>类型的<code>true</code>，否则将返回<code>false</code>。</p><p><code>s</code>修饰符表示，特殊字符<code>.</code>应另外匹配字符串中的下述行终结符（<code>line terminator characters</code>），否则将会失配：</p><ul><li>U+000A 换行符（<code>\n</code>）</li><li>U+000D 回车符（<code>\r</code>）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ul><p>这实际上意味着<code>.</code>将会匹配任意的单个<code>Unicode Basic Multilingual Plane</code> (<code>BMP</code>)字符。</p><p>若要使其与<code>astral</code>字符（大于<code>\uFFFF</code>的<code>Unicode</code>字符）匹配，你应当使用<code>u</code>（<code>Unicode</code>）修饰符。</p><p>一起使用这两个<code>修饰符</code>，<code>.</code>将无一例外地匹配任意<code>Unicode</code>字符。</p><hr><h3 id="举例">举例 <a class="markdownIt-Anchor" href="#举例">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    log(<span class="hljs-regexp">/foo.bar/</span>.test(<span class="hljs-string">'foo\nbar'</span>));   <span class="hljs-comment">// false</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，因为<code>.</code>不匹配<code>\n</code>，所以<code>正则表达式</code>返回<code>false</code>。</p><p>但是，很多时候我们希望匹配的是<code>任意单个字符</code>，这时有一种变通的写法。</p><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    log(<span class="hljs-regexp">/foo[^]bar/</span>.test(<span class="hljs-string">'foo\nbar'</span>));   <span class="hljs-comment">// true</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>这种解决方案毕竟不太符合直觉，<code>ES2018</code> 引入<code>s</code>修饰符，使得<code>.</code>可以匹配<code>任意单个字符</code>。</p><pre class="hljs"><code>/foo.bar/s.test(<span class="hljs-string">'foo\nbar'</span>) <span class="hljs-comment">// true</span>
</code></pre><p>即开启<code>dotAll</code>模式，点（<code>dot</code>）代表<code>一切字符</code>。</p><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/foo.bar/</span>s;
    <span class="hljs-comment">// 另一种写法</span>
    <span class="hljs-comment">// const re = new RegExp('foo.bar', 's');</span>

    log(re.test(<span class="hljs-string">'foo\nbar'</span>)); <span class="hljs-comment">// true</span>
    log(re.dotAll); <span class="hljs-comment">// true</span>
    log(re.flags); <span class="hljs-comment">// 's'</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip">tip <a class="markdownIt-Anchor" href="#tip">#</a></h3><p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的<code>行首</code>和<code>行尾</code>。</p><p>目前该提案属于<code>Stage 4</code>即 <code>Finished（定案阶段）</code>，预计实现时间是<code>2018年</code>，但是在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll" target="_blank" rel="noopener">MDN</a>中，关于浏览器兼容性描述是</p><pre class="hljs"><code>No compatibility data found. Please contribute data for `javascript.builtins.RegExp.dotAll`
</code></pre><p>请在使用中注意浏览器兼容性。</p><h2 id="flags-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags" target="_blank" rel="noopener">flags 属性</a> <a class="markdownIt-Anchor" href="#flags-属性">#</a></h2><h3 id="基础说明-1">基础说明 <a class="markdownIt-Anchor" href="#基础说明-1">#</a></h3><p><code>RegExp.prototype.flags</code></p><p><code>flags</code>属性返回一个字符串，由当前<code>正则表达式</code>对象的<code>修饰符标志</code>组成。</p><table><thead><tr><th style="text-align:left">特性名</th><th style="text-align:left">特性值</th></tr></thead><tbody><tr><td style="text-align:left">writable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">configurable</td><td style="text-align:left">true</td></tr></tbody></table><p><code>flags</code>属性中的标志以字典序排序（从左到右，即<code>gimsuy</code>）。</p><hr><h3 id="举例-1">举例 <a class="markdownIt-Anchor" href="#举例-1">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    log(<span class="hljs-regexp">/foo/ig</span>.flags);   <span class="hljs-comment">// `gi`</span>
    log(<span class="hljs-regexp">/bar/myu</span>.flags);  <span class="hljs-comment">// `muy`</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="polyfill">Polyfill <a class="markdownIt-Anchor" href="#polyfill">#</a></h3><pre class="hljs"><code>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegExp</span>.prototype.flags === <span class="hljs-literal">undefined</span>) {
  <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">RegExp</span>.prototype, <span class="hljs-string">'flags'</span>, {
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toString().match(<span class="hljs-regexp">/[gimsuy]*$/</span>)[<span class="hljs-number">0</span>];
    }
  });
}
</code></pre><hr><h3 id="tip-1">tip <a class="markdownIt-Anchor" href="#tip-1">#</a></h3><p>目前除了<code>Chrome</code>和<code>Firefox (Gecko)</code>两大浏览器支持外，其他浏览器没有支持</p><hr><h2 id="lastindex-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener">lastIndex 属性</a> <a class="markdownIt-Anchor" href="#lastindex-属性">#</a></h2><h3 id="使用语法">使用语法 <a class="markdownIt-Anchor" href="#使用语法">#</a></h3><pre class="hljs"><code>lastIndex = regExpObj.lastIndex;
regExpObj.lastIndex = lastIndex;
</code></pre><hr><h3 id="基础说明-2">基础说明 <a class="markdownIt-Anchor" href="#基础说明-2">#</a></h3><p><code>RegExp.lastIndex</code></p><p><code>lastIndex</code> 是正则表达式的一个<code>可读可写</code>的<code>整型</code>属性，用来指定<code>下一次匹配</code>的<code>起始索引</code>。</p><p>只有<code>正则表达式</code>使用了表示全局检索的 <code>g</code> 标志时，该<code>属性</code>才会起作用，并且<code>值</code>被<code>动态维护</code>。此时应用下面的规则：</p><ul><li>如果<code>lastIndex</code>大于字符串的长度，则 <code>regexp.test</code> 和 <code>regexp.exec</code> 将会匹配失败，然后<code>lastIndex</code>被设置为 <code>0</code>。</li><li>如果<code>lastIndex</code>等于<code>字符串</code>的<code>长度</code>，且该<code>正则表达式</code>匹配<code>空字符串</code>，则该<code>正则表达式</code>匹配从<code>lastIndex</code>开始的字符串。（then the regular expression matches input starting at lastIndex.）</li><li>如果<code>lastIndex</code>小于<code>字符串</code>的<code>长度</code>，且该<code>正则表达式</code>不匹配<code>空字符串</code> ，则该<code>正则表达式</code>不匹配<code>字符串</code>，<code>lastIndex</code> 被设置为 <code>0</code>。</li><li>否则，<code>lastIndex</code> 被设置为紧随<code>最近一次成功匹配</code>的<code>下一个位置</code>。</li></ul><hr><h3 id="举例-2">举例 <a class="markdownIt-Anchor" href="#举例-2">#</a></h3><h4 id="基础举例">基础举例 <a class="markdownIt-Anchor" href="#基础举例">#</a></h4><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/(hi)?/g</span>;
    log(re.exec(<span class="hljs-string">"hi"</span>));   <span class="hljs-comment">// ["hi", "hi", index: 0, input: "hi", groups: undefined]</span>
    log(re.lastIndex);  <span class="hljs-comment">// 2</span>

    log(re.exec(<span class="hljs-string">"hi"</span>));   <span class="hljs-comment">// ["", undefined, index: 2, input: "hi", groups: undefined]</span>
    log(re.lastIndex);  <span class="hljs-comment">// 2</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>第一次匹配完毕之后，<code>lastIndex</code>值为<code>2</code>，而<code>hi</code> 长度为<code>2</code>，即这个时候<code>lastIndex</code>等于<code>字符串</code>的<code>长度</code> ，则该<code>正则表达式</code>匹配<code>空字符串</code>，<code>正则表达式</code>匹配从<code>lastIndex</code>开始的字符串。</p><p>所以，第二次返回 <code>[&quot;&quot;, undefined]</code>，因为没有进行下一次匹配，<code>lastIndex</code>的值没有变。</p><hr><h4 id="直接指定lastindex属性">直接指定lastIndex属性 <a class="markdownIt-Anchor" href="#直接指定lastindex属性">#</a></h4><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> REGEX = <span class="hljs-regexp">/a/g</span>;

    <span class="hljs-comment">// 指定从2号位置（y）开始匹配</span>
    REGEX.lastIndex = <span class="hljs-number">2</span>;

    <span class="hljs-comment">// 匹配成功</span>
    <span class="hljs-keyword">const</span> match = REGEX.exec(<span class="hljs-string">'xaya'</span>);

    <span class="hljs-comment">// 在3号位置匹配成功</span>
    log(match.index); <span class="hljs-comment">// 3</span>

    <span class="hljs-comment">// 下一次匹配从4号位开始</span>
    log(REGEX.lastIndex); <span class="hljs-comment">// 4</span>

    <span class="hljs-comment">// 4号位开始匹配失败</span>
    log(REGEX.exec(<span class="hljs-string">'xaya'</span>)); <span class="hljs-comment">// null</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，<code>lastIndex</code>属性指定每次搜索的<code>开始位置</code>，<code>g</code>修饰符从这个位置开始<code>向后搜索</code>，直到发现匹配为止。</p><h4 id="结合y修饰符">结合<code>y</code>修饰符 <a class="markdownIt-Anchor" href="#结合y修饰符">#</a></h4><p><code>y修饰符</code>同样遵守<code>lastIndex</code>属性，但是要求必须在<code>lastIndex</code>指定的位置发现<code>匹配</code>。</p><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> REGEX = <span class="hljs-regexp">/a/y</span>;

    <span class="hljs-comment">// 指定从2号位置开始匹配</span>
    REGEX.lastIndex = <span class="hljs-number">2</span>;

    <span class="hljs-comment">// 不是粘连，匹配失败</span>
    log(REGEX.exec(<span class="hljs-string">'xaya'</span>)); <span class="hljs-comment">// null</span>

    <span class="hljs-comment">// 指定从3号位置开始匹配</span>
    REGEX.lastIndex = <span class="hljs-number">3</span>;

    <span class="hljs-comment">// 3号位置是粘连，匹配成功</span>
    <span class="hljs-keyword">const</span> match = REGEX.exec(<span class="hljs-string">'xaya'</span>);
    log(match.index); <span class="hljs-comment">// 3</span>
    log(REGEX.lastIndex);<span class="hljs-comment">// 4</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-2">tip <a class="markdownIt-Anchor" href="#tip-2">#</a></h3><p>目前所有浏览器都支持这个属性设置和获取</p><hr><h2 id="global-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global" target="_blank" rel="noopener">global 属性</a> <a class="markdownIt-Anchor" href="#global-属性">#</a></h2><h3 id="基础说明-3">基础说明 <a class="markdownIt-Anchor" href="#基础说明-3">#</a></h3><p><code>RegExp.prototype.global</code></p><p>返回值为一个<code>布尔值</code>，表示该<code>正则表达式</code>是否使用了<code>g</code> 标志。</p><p>如果使用了<code>g</code>修饰符，将返回<code>Boolean</code>类型的<code>true</code>，否则将返回<code>false</code>。</p><p><code>global</code> 是一个<code>正则表达式</code>实例的<code>只读属性</code>。</p><table><thead><tr><th style="text-align:left">特性名</th><th style="text-align:left">特性值</th></tr></thead><tbody><tr><td style="text-align:left">writable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">configurable</td><td style="text-align:left">false</td></tr></tbody></table><h3 id="举例-3">举例 <a class="markdownIt-Anchor" href="#举例-3">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/foo/g</span>;
    log(regex1.global);   <span class="hljs-comment">// true</span>

    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"g"</span>);
    log(regex2.global);   <span class="hljs-comment">// true</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-3">tip <a class="markdownIt-Anchor" href="#tip-3">#</a></h3><p>目前所有浏览器都支持这个属性获取</p><p><code>global</code>最初只是<code>RegExp</code>实例的属性，而不是<code>RegExp</code>对象的属性。</p><p><code>global</code>现在是一个<code>原型访问器属性</code>，而不是<code>实例</code>自己的<code>数据属性</code>。</p><hr><h2 id="ignorecase-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase" target="_blank" rel="noopener">ignoreCase 属性</a> <a class="markdownIt-Anchor" href="#ignorecase-属性">#</a></h2><h3 id="基础说明-4">基础说明 <a class="markdownIt-Anchor" href="#基础说明-4">#</a></h3><p><code>RegExp.prototype.ignoreCase</code></p><p>返回值为一个<code>布尔值</code>，表示该<code>正则表达式</code>是否使用了<code>i</code> 标志。</p><p>如果使用了<code>i</code>修饰符，将返回<code>Boolean</code>类型的<code>true</code>，否则将返回<code>false</code>。</p><p><code>ignoreCase</code> 是一个<code>正则表达式</code>实例的<code>只读属性</code>。</p><table><thead><tr><th style="text-align:left">特性名</th><th style="text-align:left">特性值</th></tr></thead><tbody><tr><td style="text-align:left">writable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">configurable</td><td style="text-align:left">false</td></tr></tbody></table><h3 id="举例-4">举例 <a class="markdownIt-Anchor" href="#举例-4">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/foo/gi</span>;
    log(regex1.ignoreCase);   <span class="hljs-comment">// true</span>

    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"ig"</span>);
    log(regex2.ignoreCase);   <span class="hljs-comment">// true</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-4">tip <a class="markdownIt-Anchor" href="#tip-4">#</a></h3><p>目前所有浏览器都支持这个属性获取，<code>i</code> 标志意味着在<code>字符串</code>进行匹配时，应该忽略<code>大小写</code>。</p><p><code>ignoreCase</code>最初只是<code>RegExp</code>实例的属性，而不是<code>RegExp</code>对象的属性。</p><p><code>ignoreCase</code>现在是一个<code>原型访问器属性</code>，而不是<code>实例</code>自己的<code>数据属性</code>。</p><hr><h2 id="multiline-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline" target="_blank" rel="noopener">multiline 属性</a> <a class="markdownIt-Anchor" href="#multiline-属性">#</a></h2><h3 id="基础说明-5">基础说明 <a class="markdownIt-Anchor" href="#基础说明-5">#</a></h3><p><code>RegExp.prototype.multiline</code></p><p>返回值为一个<code>布尔值</code>，表示该<code>正则表达式</code>是否使用了<code>m</code> 标志。</p><p>如果使用了<code>m</code>修饰符，将返回<code>Boolean</code>类型的<code>true</code>，否则将返回<code>false</code>。</p><p><code>multiline</code> 是一个<code>正则表达式</code>实例的<code>只读属性</code>。</p><table><thead><tr><th style="text-align:left">特性名</th><th style="text-align:left">特性值</th></tr></thead><tbody><tr><td style="text-align:left">writable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">configurable</td><td style="text-align:left">false</td></tr></tbody></table><h3 id="举例-5">举例 <a class="markdownIt-Anchor" href="#举例-5">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/foo/gm</span>;
    log(regex1.multiline);   <span class="hljs-comment">// true</span>

    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"img"</span>);
    log(regex2.multiline);   <span class="hljs-comment">// true</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-5">tip <a class="markdownIt-Anchor" href="#tip-5">#</a></h3><p>目前所有浏览器都支持这个属性获取，<code>m</code> 标志意味着一个<code>多行</code>输入字符串被看作<code>多行</code>。</p><p>例如，使用 <code>m</code>，<code>^</code> 和 <code>$</code> 将会从只匹配<code>正则字符串</code>的<code>开头</code>或<code>结尾</code>，变为匹配<code>字符串</code>中<code>任一行</code>的<code>开头</code>或<code>结尾</code>。</p><p><code>multiline</code>最初只是<code>RegExp</code>实例的属性，而不是<code>RegExp</code>对象的属性。</p><p><code>multiline</code>现在是一个<code>原型访问器属性</code>，而不是<code>实例</code>自己的<code>数据属性</code>。</p><hr><h2 id="source-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source" target="_blank" rel="noopener">source 属性</a> <a class="markdownIt-Anchor" href="#source-属性">#</a></h2><h3 id="基础说明-6">基础说明 <a class="markdownIt-Anchor" href="#基础说明-6">#</a></h3><p><code>RegExp.prototype.source</code></p><p><code>source</code> 属性返回一个值为当前<code>正则表达式</code>对象<code>模式文本</code>的<code>字符串</code>，该<code>字符串</code>不会包含<code>正则字面量</code>两边的<code>斜杠</code>以及任何的<code>修饰符</code>字符。</p><h3 id="举例-6">举例 <a class="markdownIt-Anchor" href="#举例-6">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/foo/gm</span>;
    log(regex1.source);   <span class="hljs-comment">// foo</span>

    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"img"</span>);
    log(regex2.source);   <span class="hljs-comment">// foo</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-6">tip <a class="markdownIt-Anchor" href="#tip-6">#</a></h3><p>目前所有浏览器都支持这个属性获取</p><p><code>source</code>最初只是<code>RegExp</code>实例的属性，而不是<code>RegExp</code>对象的属性。</p><p><code>source</code>现在是一个<code>原型访问器属性</code>，而不是<code>实例</code>自己的<code>数据属性</code>。</p><hr><h2 id="sticky-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky" target="_blank" rel="noopener">sticky 属性</a> <a class="markdownIt-Anchor" href="#sticky-属性">#</a></h2><h3 id="基础说明-7">基础说明 <a class="markdownIt-Anchor" href="#基础说明-7">#</a></h3><p><code>RegExp.prototype.sticky</code></p><p>返回值为一个<code>布尔值</code>，表示该<code>正则表达式</code>是否使用了<code>y</code> 标志，即<code>搜索</code>是否具有<code>粘性</code>（ 仅从正则表达式的 <code>lastIndex</code> 属性表示的<code>索引</code>处搜索 ）。</p><p>如果使用了<code>y</code>修饰符，将返回<code>Boolean</code>类型的<code>true</code>，否则将返回<code>false</code>。</p><p><code>sticky</code> 是一个<code>正则表达式</code>实例的<code>只读属性</code>。</p><table><thead><tr><th style="text-align:left">特性名</th><th style="text-align:left">特性值</th></tr></thead><tbody><tr><td style="text-align:left">writable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">configurable</td><td style="text-align:left">false</td></tr></tbody></table><h3 id="举例-7">举例 <a class="markdownIt-Anchor" href="#举例-7">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/foo/y</span>;
    log(regex1.sticky);   <span class="hljs-comment">// true</span>

    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"y"</span>);
    log(regex2.sticky);   <span class="hljs-comment">// true</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-7">tip <a class="markdownIt-Anchor" href="#tip-7">#</a></h3><p>目前<code>Chrome</code>，<code>Edge</code>和<code>Firefox (Gecko)</code>浏览器支持该属性获取。</p><p>当使用带有<code>y</code>标识的匹配模式时，<code>^</code>断言总是会匹配<code>输入</code>的<code>开始位置</code>或者（如果是<code>多行模式</code>）每一行的<code>开始位置</code>。</p><p>可以使用 <code>try { … } catch { … }</code> 来测试运行时（<code>run-time</code>）是否支持 <code>sticky</code> 标志。</p><p>这种情况下，必须使用 <code>eval(…)</code> 表达式或 <code>RegExp(regex-string, flags-string)</code> 语法（这是由于 <code>/regex/flags</code> 表示法将会在<code>编译</code>时刻被处理，因此在 <code>catch</code> 语句块处理异常前就会抛出一个<code>异常</code>。</p><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> supports_sticky;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">''</span>,<span class="hljs-string">'y'</span>);
        supports_sticky = <span class="hljs-literal">true</span>;
    }<span class="hljs-keyword">catch</span>(e) {
        supports_sticky = <span class="hljs-literal">false</span>;
    }
    log(supports_sticky); <span class="hljs-comment">// true</span>

})(<span class="hljs-built_in">console</span>.log)

</code></pre><hr><h2 id="unicode-属性"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode" target="_blank" rel="noopener">unicode 属性</a> <a class="markdownIt-Anchor" href="#unicode-属性">#</a></h2><h3 id="基础说明-8">基础说明 <a class="markdownIt-Anchor" href="#基础说明-8">#</a></h3><p><code>RegExp.prototype.unicode</code></p><p>返回值为一个<code>布尔值</code>，表示该<code>正则表达式</code>是否使用了<code>u</code> 标志。</p><p>如果使用了<code>u</code>修饰符，将返回<code>Boolean</code>类型的<code>true</code>，否则将返回<code>false</code>。</p><p><code>unicode</code> 是一个<code>正则表达式</code>实例的<code>只读属性</code>。</p><table><thead><tr><th style="text-align:left">特性名</th><th style="text-align:left">特性值</th></tr></thead><tbody><tr><td style="text-align:left">writable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">configurable</td><td style="text-align:left">false</td></tr></tbody></table><h3 id="举例-8">举例 <a class="markdownIt-Anchor" href="#举例-8">#</a></h3><pre class="hljs"><code>(<span class="hljs-function">(<span class="hljs-params">log</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> regex1 = <span class="hljs-regexp">/\u{61}/u</span>;
    log(regex1.unicode);   <span class="hljs-comment">// true</span>
    log(regex1.source);   <span class="hljs-comment">// \u{61}</span>

    <span class="hljs-keyword">const</span> regex2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'\u{61}'</span>, <span class="hljs-string">'u'</span>);
    log(regex2.unicode);   <span class="hljs-comment">// true</span>
    log(regex2.source);   <span class="hljs-comment">// a</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="tip-8">tip <a class="markdownIt-Anchor" href="#tip-8">#</a></h3><p>目前<code>Chrome</code>，<code>Edge</code>和<code>Firefox (Gecko)</code>浏览器支持该属性获取。</p><p><code>u</code> 标志开启了多种 <code>Unicode</code> 相关的特性。使用 <code>u</code> 标志，任何 <code>Unicode</code> 代码点的<code>转译</code>都会被<code>解释</code>。</p><p>注意开启<code>u</code> 标志，最好结合<code>构造函数</code>进行使用，如果是<code>字面量</code>的<code>正则表达式</code>，则内容是不会<code>转译</code>的。</p><hr><h2 id="mdn地址">MDN地址 <a class="markdownIt-Anchor" href="#mdn地址">#</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters05/base.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters05/modifier.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item chapter-item-current"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters05/prototype-attribute.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#dotall-%E5%B1%9E%E6%80%A7">dotAll 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B">举例</a></li>\n<li><a href="#tip">tip</a></li>\n</ul>\n</li>\n<li><a href="#flags-%E5%B1%9E%E6%80%A7">flags 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-1">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-1">举例</a></li>\n<li><a href="#polyfill">Polyfill</a></li>\n<li><a href="#tip-1">tip</a></li>\n</ul>\n</li>\n<li><a href="#lastindex-%E5%B1%9E%E6%80%A7">lastIndex 属性</a>\n<ul>\n<li><a href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95">使用语法</a></li>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-2">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-2">举例</a></li>\n<li><a href="#tip-2">tip</a></li>\n</ul>\n</li>\n<li><a href="#global-%E5%B1%9E%E6%80%A7">global 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-3">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-3">举例</a></li>\n<li><a href="#tip-3">tip</a></li>\n</ul>\n</li>\n<li><a href="#ignorecase-%E5%B1%9E%E6%80%A7">ignoreCase 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-4">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-4">举例</a></li>\n<li><a href="#tip-4">tip</a></li>\n</ul>\n</li>\n<li><a href="#multiline-%E5%B1%9E%E6%80%A7">multiline 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-5">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-5">举例</a></li>\n<li><a href="#tip-5">tip</a></li>\n</ul>\n</li>\n<li><a href="#source-%E5%B1%9E%E6%80%A7">source 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-6">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-6">举例</a></li>\n<li><a href="#tip-6">tip</a></li>\n</ul>\n</li>\n<li><a href="#sticky-%E5%B1%9E%E6%80%A7">sticky 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-7">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-7">举例</a></li>\n<li><a href="#tip-7">tip</a></li>\n</ul>\n</li>\n<li><a href="#unicode-%E5%B1%9E%E6%80%A7">unicode 属性</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E-8">基础说明</a></li>\n<li><a href="#%E4%B8%BE%E4%BE%8B-8">举例</a></li>\n<li><a href="#tip-8">tip</a></li>\n</ul>\n</li>\n<li><a href="#mdn%E5%9C%B0%E5%9D%80">MDN地址</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
# RegExp 构造函数

## 基础语法

`字面量`, `构造函数`和`工厂符号`都是可以的：

```javascript
// 字面量
/pattern/flags

// 构造函数
new RegExp(pattern [, flags])

// 工厂符号
RegExp(pattern [, flags])
```

## 参数说明

### pattern

正则表达式的文本。

### flags

如果指定，标志可以具有以下值的任意组合：
| 名称 | 具体说明                                                                                                                                                 |
| :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------- |
| g        | 全局匹配;找到所有匹配，而不是在第一个匹配后停止                                                                                                          |
| i        | 忽略大小写                                                                                                                                               |
| m        | 多行; 将开始和结束字符（`^`和`$`）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 `\n` 或 `\r` 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。 |
| u        | Unicode; 将模式视为`Unicode`序列点的序列                                                                                                                   |
| y        | 粘性匹配; 仅匹配目标字符串中此`正则表达式`的`lastIndex`属性指示的索引(并且不尝试从任何`后续`的`索引`匹配)。                                                      |

## 详细说明

### 基础使用

有两种方法来创建一个`RegExp`对象：一是`字面量`、二是`构造函数`。

如果`pattern`为`字符串`或者`字面量`构成，参数不需要使用`引号`，而`构造函数`的`参数`使用`引号`。

因此，以下`表达式`创建相同的`正则表达式`：

```javascript
// 字面量
/ab+c/i;

// 构造函数
new RegExp('ab+c', 'i');

// 工厂符号
new RegExp(/ab+c/, 'i');
```

### 重新编译

当`表达式`被`赋值`时，`字面量`形式提供`正则表达式`的编译（`compilation`）状态，当`正则表达式`保持为`常量`时使用`字面量`。

例如当你在`循环`中使用`字面量`构造一个`正则表达式`时，`正则表达式`不会在每一次`迭代`中都被`重新编译`（`recompiled`）。
而正则表达式对象的构造函数，如 `new RegExp('ab+c')` 提供了`正则表达式`运行时编译（`runtime compilation`）。

如果你知道`正则表达式`模式将会改变，或者你事先不知道什么`模式`，而是从另一个`来源`获取，如用户输入，这些情况都可以使用`构造函数`。

### 字符转义规则

当使用`构造函数`创造`正则对象`时，需要`常规`的`字符转义`规则（在前面加反斜杠 `\`）。比如，以下是等价的：

```javascript

new RegExp("\\w+");

/\w+/;
```

### ES6 新支持

在`ES5`中， 当第一个`pattern`为`正则对象`，不允许此时使用第二个`参数`添加`修饰符`，否则会报错`TypeError(Uncaught TypeError: Cannot supply flags when constructing one RegExp from another)`的异常。

```javascript
const regex = new RegExp(/xyz/, 'i');
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
// 当从其他正则表达式进行构造时不支持标志
```

`ES6` 改变了这种行为。如果`RegExp`构造函数第一个`pattern`为`正则对象`，那么可以使用第二个`参数`指定`修饰符`。

而且，返回的`正则表达式`会忽略原有的`正则表达式`的`修饰符`，只使用新指定的`修饰符`。

```javascript

new RegExp(/abc/ig, 'i').flags
// "i"
```

上面代码中，原有正则对象的修饰符是`ig`，它会被第二个参数`i`覆盖。

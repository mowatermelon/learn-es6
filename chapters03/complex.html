<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>复杂数据结构 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters03/index.html" class="breadcrumb-item">第三章 变量的解构赋值</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters03/complex.html" class="breadcrumb-item">复杂数据结构</a></div><h1 class="article-title">复杂数据结构</h1><div class="article"><h2 id="数组的解构赋值">数组的解构赋值 <a class="markdownIt-Anchor" href="#数组的解构赋值">#</a></h2><h3 id="基础用法">基础用法 <a class="markdownIt-Anchor" href="#基础用法">#</a></h3><blockquote><p>完全解构</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-comment">// 基础数组解构</span>
    <span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    log(a); <span class="hljs-comment">// 1</span>
    log(b); <span class="hljs-comment">// 2</span>
    log(c); <span class="hljs-comment">// 3</span>

    <span class="hljs-comment">// 嵌套数组解构</span>
    <span class="hljs-keyword">const</span> [foo, [[bar], baz]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]];
    log(foo); <span class="hljs-comment">// 1</span>
    log(bar); <span class="hljs-comment">// 2</span>
    log(baz); <span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> [ , , third] = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"baz"</span>];
    log(third); <span class="hljs-comment">// "baz"</span>

    <span class="hljs-keyword">const</span> [x, , y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    log(x); <span class="hljs-comment">// 1</span>
    log(y); <span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    log(head); <span class="hljs-comment">// 1</span>
    log(tail); <span class="hljs-comment">// [2, 3, 4]</span>

    <span class="hljs-keyword">const</span> [e, f, ...g] = [<span class="hljs-string">'a'</span>];
    log(e); <span class="hljs-comment">// "a"</span>
    log(f); <span class="hljs-comment">// undefined</span>
    log(g); <span class="hljs-comment">// []</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><blockquote><p>不完全解构</p></blockquote><p>另一种情况是<code>不完全解构</code>，即等号左边的模式，只匹配<code>一部分</code>的等号右边的数组。这种情况下，解构依然可以成功。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    log(x); <span class="hljs-comment">// 1</span>
    log(y); <span class="hljs-comment">// 2</span>

    <span class="hljs-keyword">const</span> [a, [b], d] = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>];
    log(a); <span class="hljs-comment">// 1</span>
    log(b); <span class="hljs-comment">// 2</span>
    log(d); <span class="hljs-comment">// 4</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面两个例子，都属于<code>不完全解构</code>，但是可以成功。</p><hr><blockquote><p>Set结构解构</p></blockquote><p>对于 <code>Set</code> 结构，也可以使用<code>数组</code>的解构赋值。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> [x, y, z] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>]);
    log(x); <span class="hljs-comment">// "a"</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><blockquote><p>Generator 函数解构</p></blockquote><p>事实上，只要某种数据结构具有 <code>Iterator</code> 接口，都可以采用<code>数组</code>形式的<code>解构赋值</code>。</p><pre class="hljs"><code>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fibs</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> a = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> b = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">yield</span> a;
            [a, b] = [b, a + b];
        }
    }

    <span class="hljs-keyword">const</span> [first, second, third, fourth, fifth, sixth,seventh] = fibs();
    <span class="hljs-comment">// yield 等待的是未做值替换之前的a值</span>
    <span class="hljs-comment">// 第一次 a 为 0 ，b 为 1</span>
    <span class="hljs-comment">// 第二次 a 为 1 ，b 为 1</span>
    <span class="hljs-comment">// 第三次 a 为 1 ，b 为 2</span>
    <span class="hljs-comment">// 第四次 a 为 2 ，b 为 3</span>
    <span class="hljs-comment">// 第五次 a 为 3 ，b 为 5</span>
    <span class="hljs-comment">// 第六次 a 为 5 ，b 为 8</span>
    log(first); <span class="hljs-comment">// 0</span>
    log(second); <span class="hljs-comment">// 1</span>
    log(third); <span class="hljs-comment">// 1</span>
    log(fourth); <span class="hljs-comment">// 2</span>
    log(fifth); <span class="hljs-comment">// 3</span>
    log(sixth); <span class="hljs-comment">// 5</span>
    log(seventh); <span class="hljs-comment">// 8</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，<code>fibs</code>是一个 <code>Generator</code> 函数（参见<code>《Generator 函数》</code>一章），原生具有 <code>Iterator</code> 接口。解构赋值会依次从这个<code>接口</code>获取值。</p><hr><h3 id="设置默认值">设置默认值 <a class="markdownIt-Anchor" href="#设置默认值">#</a></h3><blockquote><p>基础使用</p></blockquote><p>解构赋值允许指定默认值。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> [foo = <span class="hljs-literal">true</span>] = [];
    log(foo); <span class="hljs-comment">// true</span>

    <span class="hljs-keyword">const</span> [x, y = <span class="hljs-string">'b'</span>] = [<span class="hljs-string">'a'</span>];
    log(x);<span class="hljs-comment">// 'a'</span>
    log(y);<span class="hljs-comment">// 'b'</span>

    <span class="hljs-keyword">const</span> [a, b = <span class="hljs-string">'b'</span>] = [<span class="hljs-string">'a'</span>, <span class="hljs-literal">undefined</span>];
    log(a);<span class="hljs-comment">// 'a'</span>
    log(b);<span class="hljs-comment">// 'b'</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><blockquote><p>使用表达式</p></blockquote><p>如果默认值是一个<code>表达式</code>，那么这个<code>表达式</code>是<code>惰性求值</code>的，即只有在用到的时候，才会<code>求值</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'aaa'</span>);
    }

    <span class="hljs-keyword">const</span> [x = f()] = [<span class="hljs-number">1</span>];
    log(x);<span class="hljs-comment">// 1</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> x;
    <span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) {
        x = f();
    } <span class="hljs-keyword">else</span> {
        x = [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
    }
    log(x);<span class="hljs-comment">// 1</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><blockquote><p>引用其他变量值</p></blockquote><p><code>默认值</code>可以引用<code>解构赋值</code>的<code>其他变量</code>，但该<code>变量</code>必须<code>已经声明</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> [x1 = <span class="hljs-number">1</span>, y1 = x1] = [];
    log(x1);<span class="hljs-comment">// 1</span>
    log(y1);<span class="hljs-comment">// 1</span>

    <span class="hljs-keyword">const</span> [x2 = <span class="hljs-number">1</span>, y2 = x2] = [<span class="hljs-number">2</span>];
    log(x2);<span class="hljs-comment">// 2</span>
    log(y2);<span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> [x3 = <span class="hljs-number">1</span>, y3 = x3] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
    log(x3);<span class="hljs-comment">// 1</span>
    log(y3);<span class="hljs-comment">// 2</span>

    <span class="hljs-keyword">const</span> [x4 = y4, y4 = <span class="hljs-number">1</span>] = [];     <span class="hljs-comment">// ReferenceError: y is not defined</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面最后一个<code>表达式</code>之所以会报错，是因为<code>x4</code>用<code>y4</code>做默认值时，<code>y4</code>还没有<code>声明</code>。</p><hr><h3 id="注意事项">注意事项 <a class="markdownIt-Anchor" href="#注意事项">#</a></h3><blockquote><p>解构不成功</p></blockquote><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><pre class="hljs"><code>
<span class="hljs-keyword">const</span> [foo] = [];
<span class="hljs-keyword">const</span> [bar, foo] = [<span class="hljs-number">1</span>];
</code></pre><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p><hr><blockquote><p>不可遍历结构</p></blockquote><p>如果等号的右边不是<code>数组</code>（或者严格地说，不是<code>可遍历</code>的结构，参见<code>《Iterator》</code>一章），那么将会报错。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-comment">// 报错</span>
    <span class="hljs-keyword">const</span> [foo1] = <span class="hljs-number">1</span>;<span class="hljs-comment">// TypeError: 1 is not iterable</span>
    <span class="hljs-keyword">const</span> [foo2] = <span class="hljs-literal">false</span>;<span class="hljs-comment">// TypeError: false is not iterable</span>
    <span class="hljs-keyword">const</span> [foo3] = <span class="hljs-literal">NaN</span>;<span class="hljs-comment">// TypeError: NaN is not iterable</span>
    <span class="hljs-keyword">const</span> [foo4] = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// TypeError: undefined is not iterable</span>
    <span class="hljs-keyword">const</span> [foo5] = <span class="hljs-literal">null</span>;<span class="hljs-comment">// TypeError: null is not iterable</span>
    <span class="hljs-keyword">const</span> [foo6] = {};<span class="hljs-comment">// TypeError: {} is not iterable</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面的语句都会<code>报错</code>，因为等号右边的值，要么转为<code>对象</code>以后不具备 <code>Iterator</code> 接口（前五个表达式），要么<code>本身</code>就不具备 <code>Iterator</code> 接口（最后一个表达式）。</p><hr><h2 id="对象的解构赋值">对象的解构赋值 <a class="markdownIt-Anchor" href="#对象的解构赋值">#</a></h2><h3 id="基础用法-1">基础用法 <a class="markdownIt-Anchor" href="#基础用法-1">#</a></h3><blockquote><p>基础使用</p></blockquote><p><code>解构</code>不仅可以用于<code>数组</code>，还可以用于<code>对象</code>。</p><p><code>对象</code>的<code>解构</code>与<code>数组</code>有一个重要的不同。数组的元素是按<code>次序</code>排列的，<code>变量</code>的<code>取值</code>由它的<code>位置</code>决定；</p><p>而<code>对象</code>的<code>属性</code>没有<code>次序</code>，<code>变量</code>必须与<code>属性</code>同名，才能取到<code>正确</code>的值。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        bar,
        foo
    } = {
        <span class="hljs-attr">foo</span>: <span class="hljs-string">"aaa"</span>,
        <span class="hljs-attr">bar</span>: <span class="hljs-string">"bbb"</span>
    };
    log(foo); <span class="hljs-comment">// "aaa"</span>
    log(bar); <span class="hljs-comment">// "bbb"</span>

    <span class="hljs-keyword">const</span> {
        baz
    } = {
        <span class="hljs-attr">foo</span>: <span class="hljs-string">"aaa"</span>,
        <span class="hljs-attr">bar</span>: <span class="hljs-string">"bbb"</span>
    };
    log(baz); <span class="hljs-comment">// undefined</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码的第一个例子，等号左边的两个变量的<code>次序</code>，与等号右边两个同名属性的<code>次序</code>不一致，但是对取值完全没有影响。</p><p>第二个例子的<code>变量</code>没有对应的同名<code>属性</code>，导致取不到值，最后等于<code>undefined</code>。</p><blockquote><p>变量名与属性名不一致</p></blockquote><p>如果<code>变量名</code>与<code>属性名</code>不一致，必须写成下面这样。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">foo</span>: baz
    } = {
        <span class="hljs-attr">foo</span>: <span class="hljs-string">'aaa'</span>,
        <span class="hljs-attr">bar</span>: <span class="hljs-string">'bbb'</span>
    };
    log(baz); <span class="hljs-comment">// "aaa"</span>

    <span class="hljs-keyword">const</span> obj = {
        <span class="hljs-attr">first</span>: <span class="hljs-string">'hello'</span>,
        <span class="hljs-attr">last</span>: <span class="hljs-string">'world'</span>
    };
    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">first</span>: f,
        <span class="hljs-attr">last</span>: l
    } = obj;
    log(f); <span class="hljs-comment">// 'hello'</span>
    log(l); <span class="hljs-comment">// 'world'</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>这实际上说明，<code>对象</code>的<code>解构赋值</code>是下面形式的<code>简写</code>（参见<code>《对象的扩展》</code>一章）。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">foo</span>: foo,
        <span class="hljs-attr">bar</span>: bar
    } = {
        <span class="hljs-attr">foo</span>: <span class="hljs-string">"aaa"</span>,
        <span class="hljs-attr">bar</span>: <span class="hljs-string">"bbb"</span>
    };
    log(foo); <span class="hljs-comment">// "aaa"</span>
    log(bar); <span class="hljs-comment">// "bbb"</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>也就是说，对象的<code>解构赋值</code>的<code>内部机制</code>，是先找到<code>同名属性</code>，然后再赋给对应的<code>变量</code>。</p><p>真正被<code>赋值</code>的是<code>后者</code>，而不是<code>前者</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">foo</span>: baz
    } = {
        <span class="hljs-attr">foo</span>: <span class="hljs-string">"aaa"</span>,
        <span class="hljs-attr">bar</span>: <span class="hljs-string">"bbb"</span>
    };
    log(baz); <span class="hljs-comment">// "aaa"</span>
    log(foo); <span class="hljs-comment">// ReferenceError: foo is not defined</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，<code>foo</code>是匹配的<code>模式</code>，<code>baz</code>才是<code>变量</code>。</p><p>真正被<code>赋值</code>的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><hr><blockquote><p>解构对象方法</p></blockquote><p><code>对象</code>的<code>解构赋值</code>，可以很方便地将现有<code>对象</code>的方法，赋值到某个<code>变量</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">log</span>: log1,
        sin,
        cos
    } = <span class="hljs-built_in">Math</span>;
    log(log1); <span class="hljs-comment">// [Function: log]</span>
    log(sin); <span class="hljs-comment">// [Function: sin]</span>
    log(cos); <span class="hljs-comment">// [Function: cos]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码将<code>Math</code>对象的<code>对数</code>、<code>正弦</code>、<code>余弦</code>三个方法，<code>赋值</code>到对应的<code>变量</code>上，使用起来就会方便很多。</p><hr><blockquote><p>属性名表达式</p></blockquote><p>由于<code>数组</code>本质是特殊的<code>对象</code>，因此可以对<code>数组</code>进行<code>对象属性</code>的<code>解构</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-keyword">const</span> {
        <span class="hljs-number">0</span>: first,
        [arr.length - <span class="hljs-number">1</span>]: last
    } = arr;
    log(first); <span class="hljs-comment">// 1</span>
    log(last); <span class="hljs-comment">// 3</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。</p><p><code>方括号</code>这种写法，属于<code>属性名表达式</code>（参见<code>《对象的扩展》</code>一章）。</p><hr><blockquote><p>基础嵌套对象解构</p></blockquote><p>与<code>数组</code>一样，解构也可以用于<code>嵌套结构</code>的<code>对象</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> obj = {
        <span class="hljs-attr">p</span>: [
            <span class="hljs-string">'Hello'</span>,
            {
                <span class="hljs-attr">y</span>: <span class="hljs-string">'Melon'</span>
            }
        ]
    };

    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">p</span>: [x, {
            y
        }]
    } = obj;
    log(x); <span class="hljs-comment">// "Hello"</span>
    log(y); <span class="hljs-comment">// "Melon"</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>注意，这时<code>p</code>是<code>模式</code>，不是<code>变量</code>，因此不会被<code>赋值</code>。</p><p>如果<code>p</code>也要作为<code>变量</code>赋值，可以写成下面这样。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> obj = {
        <span class="hljs-attr">p</span>: [
            <span class="hljs-string">'Hello'</span>,
            {
                <span class="hljs-attr">y</span>: <span class="hljs-string">'Melon'</span>
            }
        ]
    };

    <span class="hljs-keyword">const</span> {
        p,
        <span class="hljs-attr">p</span>: [x, {
            y
        }]
    } = obj;
    log(x); <span class="hljs-comment">// "Hello"</span>
    log(y); <span class="hljs-comment">// "Melon"</span>
    log(p); <span class="hljs-comment">// [ 'Hello', { y: 'Melon' } ]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><blockquote><p>多重嵌套对象解构</p></blockquote><p>与<code>数组</code>一样，解构也可以用于<code>嵌套结构</code>的<code>对象</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> node = {
        <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">start</span>: {
                <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">column</span>: <span class="hljs-number">5</span>
            }
        }
    };

    <span class="hljs-keyword">const</span> {
        loc,
        <span class="hljs-attr">loc</span>: {
            start
        },
        <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">start</span>: {
                line
            }
        }
    } = node;
    log(line); <span class="hljs-comment">// 1</span>
    log(loc); <span class="hljs-comment">// { start: { line: 1, column: 5 } }</span>
    log(start); <span class="hljs-comment">// { line: 1, column: 5 }</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个<code>属性</code>的<code>解构赋值</code>。</p><p>注意，最后一次对<code>line</code>属性的<code>解构赋值</code>之中，只有<code>line</code>是<code>变量</code>，<code>loc</code>和<code>start</code>都是<code>模式</code>，不是<code>变量</code>。</p><hr><blockquote><p>结合数组进行嵌套赋值</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> obj = {};
    <span class="hljs-keyword">const</span> arr = [];

    ({
        <span class="hljs-attr">foo</span>: obj.prop,
        <span class="hljs-attr">bar</span>: arr[<span class="hljs-number">0</span>]
    } = {
        <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span>,
        <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span>
    });

    log(obj); <span class="hljs-comment">// { prop: 123 }</span>
    log(arr); <span class="hljs-comment">// [ true ]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="设置默认值-1">设置默认值 <a class="markdownIt-Anchor" href="#设置默认值-1">#</a></h3><p><code>对象</code>的<code>解构</code>也可以指定<code>默认值</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        x1 = <span class="hljs-number">3</span>
    } = {};
    log(x1); <span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> {
        x2,
        y2 = <span class="hljs-number">5</span>
    } = {
        <span class="hljs-attr">x2</span>: <span class="hljs-number">1</span>
    };
    log(x2); <span class="hljs-comment">// 1</span>
    log(y2); <span class="hljs-comment">// 5</span>

    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">x3</span>: y3 = <span class="hljs-number">3</span>
    } = {};
    <span class="hljs-comment">// log(x3); // ReferenceError: x3 is not defined</span>
    log(y3); <span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">x4</span>: y4 = <span class="hljs-number">3</span>
    } = {
        <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>
    };
    <span class="hljs-comment">// log(x4); // ReferenceError: x4 is not defined</span>
    log(y4); <span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> {
        <span class="hljs-attr">message</span>: msg = <span class="hljs-string">'Something went wrong'</span>
    } = {};
    log(msg); <span class="hljs-comment">// "Something went wrong"</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p><code>默认值</code>生效的条件是，对象的<code>属性值</code>严格等于<code>undefined</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {
        x1 = <span class="hljs-number">3</span>
    } = {
        <span class="hljs-attr">x1</span>: <span class="hljs-literal">undefined</span>
    };
    log(x1); <span class="hljs-comment">// 3</span>

    <span class="hljs-keyword">const</span> {
        x2 = <span class="hljs-number">3</span>
    } = {
        <span class="hljs-attr">x2</span>: <span class="hljs-literal">null</span>
    };
    log(x2); <span class="hljs-comment">// null</span>

})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的<code>赋值</code>，导致默认值<code>3</code>不会生效。</p><hr><h3 id="注意事项-1">注意事项 <a class="markdownIt-Anchor" href="#注意事项-1">#</a></h3><blockquote><p>解构不成功</p></blockquote><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> {foo} = {<span class="hljs-attr">bar</span>: <span class="hljs-string">'baz'</span>};
    log(foo); <span class="hljs-comment">// undefined</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><blockquote><p>父属性不存在</p></blockquote><p>如果解构模式是<code>嵌套</code>的对象，而且<code>子对象</code>所在的<code>父属性</code>不存在，那么将会<code>报错</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-comment">// 报错</span>
    <span class="hljs-keyword">const</span> {<span class="hljs-attr">foo</span>: {bar}} = {<span class="hljs-attr">baz</span>: <span class="hljs-string">'baz'</span>};<span class="hljs-comment">// TypeError: Cannot destructure property `bar` of 'undefined' or 'null'.</span>

    <span class="hljs-keyword">const</span> _tmp = {<span class="hljs-attr">baz</span>: <span class="hljs-string">'baz'</span>};
    _tmp.foo.bar <span class="hljs-comment">// Cannot read property 'bar' of undefined</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个<code>子对象</code>。该<code>子对象</code>的<code>bar</code>属性，<code>解构</code>时会报错。</p><p>原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，类似于上文的<code>_tmp.foo.bar</code>,再取<code>子属性</code>就会报错。</p><hr><blockquote><p>已经声明的变量</p></blockquote><p>如果要将一个已经<code>声明</code>的<code>变量</code>用于<code>解构赋值</code>，必须非常小心。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-comment">// 错误的写法</span>
    <span class="hljs-keyword">const</span> x;
    {x} = {<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>};
    <span class="hljs-comment">// SyntaxError: Unexpected token =</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码的写法会报错，因为 <code>JavaScript</code> 引擎会将<code>{x}</code>理解成一个代码块，从而发生<code>语法错误</code>。</p><p>只有不将<code>大括号</code>写在<code>行首</code>，避免 <code>JavaScript</code> 将其解释为<code>代码块</code>，才能解决这个问题。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-comment">// 正确的写法</span>
    <span class="hljs-keyword">const</span> x;
    ({x} = {<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>});
    log(x);<span class="hljs-comment">// 1</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码将整个<code>解构赋值</code>语句，放在一个<code>圆括号</code>里面，就可以正确执行。</p><hr><h2 id="函数的解构赋值">函数的解构赋值 <a class="markdownIt-Anchor" href="#函数的解构赋值">#</a></h2><h3 id="基础用法-2">基础用法 <a class="markdownIt-Anchor" href="#基础用法-2">#</a></h3><blockquote><p>基础使用</p></blockquote><p><code>函数</code>的<code>参数</code>也可以使用<code>解构赋值</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">[x, y]</span>) </span>{
        <span class="hljs-keyword">return</span> x + y;
    }

    log(add([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// 3</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，函数<code>add</code>的<code>参数</code>表面上是一个<code>数组</code>，但在传入<code>参数</code>的那一刻，<code>数组参数</code>就被解构成变量<code>x</code>和<code>y</code>。对于<code>函数内部</code>的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p><hr><blockquote><p>结合箭头函数使用</p></blockquote><p><code>函数</code>的<code>参数</code>也可以使用<code>解构赋值</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> arr = [
        [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
        [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
    ].map(<span class="hljs-function">(<span class="hljs-params">[a, b]</span>) =&gt;</span> a + b);
    log(arr); <span class="hljs-comment">// [ 3, 7 ]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr><h3 id="设置默认值-2">设置默认值 <a class="markdownIt-Anchor" href="#设置默认值-2">#</a></h3><p><code>函数参数</code>的<code>解构</code>也可以使用<code>默认值</code>。</p><blockquote><p>函数对象参数属性使用默认值</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">{
        x = <span class="hljs-number">0</span>,
        y = <span class="hljs-number">0</span>
    } = {}</span>) </span>{
        <span class="hljs-keyword">return</span> [x, y];
    }

    log(move({
        <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">8</span>
    })); <span class="hljs-comment">// [3, 8]</span>
    log(move({
        <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>
    })); <span class="hljs-comment">// [3, 0]</span>
    log(move({})); <span class="hljs-comment">// [0, 0]</span>
    log(move()); <span class="hljs-comment">// [0, 0]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码中，函数<code>move</code>的<code>参数</code>是一个<code>对象</code>，通过对这个<code>对象</code>进行<code>解构</code>，得到变量<code>x</code>和<code>y</code>的值。如果<code>解构</code>失败，<code>x</code>和<code>y</code>等于<code>默认值</code>。</p><hr><blockquote><p>函数对象参数使用默认值</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">{
        x,
        y
    } = {
        x: <span class="hljs-number">0</span>,
        y: <span class="hljs-number">0</span>
    }</span>) </span>{
        <span class="hljs-keyword">return</span> [x, y];
    }

    log(move({
        <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">8</span>
    })); <span class="hljs-comment">// [3, 8]</span>
    log(move({
        <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>
    })); <span class="hljs-comment">// [3, undefined]</span>
    log(move({})); <span class="hljs-comment">// [undefined, undefined]</span>
    log(move()); <span class="hljs-comment">// [0, 0]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><p>上面代码是为函数<code>move</code>的<code>参数</code>指定<code>默认值</code>，而不是为变量<code>x</code>和<code>y</code>指定<code>默认值</code>，所以会得到与前一种写法不同的结果。</p><hr><h3 id="注意事项-2">注意事项 <a class="markdownIt-Anchor" href="#注意事项-2">#</a></h3><p><code>undefined</code>就会触发<code>函数参数</code>的<code>默认值</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">log</span>) </span>{
    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">x = <span class="hljs-string">'yes'</span></span>) =&gt;</span> x);
    log(arr); <span class="hljs-comment">// [ 1, 'yes', 3 ]</span>
})(<span class="hljs-built_in">console</span>.log)
</code></pre><hr></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters03/base.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters03/parentheses.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item chapter-item-current"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters03/complex.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">数组的解构赋值</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">基础用法</a></li>\n<li><a href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC">设置默认值</a></li>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>\n</ul>\n</li>\n<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">对象的解构赋值</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-1">基础用法</a></li>\n<li><a href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC-1">设置默认值</a></li>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1">注意事项</a></li>\n</ul>\n</li>\n<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">函数的解构赋值</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-2">基础用法</a></li>\n<li><a href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC-2">设置默认值</a></li>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2">注意事项</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
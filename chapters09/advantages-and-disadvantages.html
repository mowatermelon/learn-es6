<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>ts优势与劣势 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters09/index.html" class="breadcrumb-item">第九章 ts学习</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters09/advantages-and-disadvantages.html" class="breadcrumb-item">ts优势与劣势</a></div><h1 class="article-title">ts优势与劣势</h1><div class="article"><h2 id="ts背景">ts背景 <a class="markdownIt-Anchor" href="#ts背景">#</a></h2><p><code>TypeScript</code> 起源于开发应用程序规模的 <code>JavaScript</code> 应用程序的需求。<code>Microsoft</code>的语言开发者们，说内部以及外部的客户都表示他们构建 <code>JavaScript</code> 代码的问题。</p><p>很多最终依赖于 <code>JavaScript</code> 的开发者通常用编译为 <code>JavaScript</code> 代码的另一种语言写脚本，例如 <code>CoffeeScript</code> 和 <code>Script#</code> (读作 <code>ScriptSharp</code>)。</p><p>一个明显的<code>劣势</code>是也许无法从那另一种语言使用任何 <code>JavaScript</code> 的具体的语言特性，如果那种语言不支持它的话。</p><p>在 <code>Microsoft</code> 内部，它导致了自定义工具以简化 <code>JavaScript</code> 组件的编写的需求。</p><hr><h2 id="ts官网">ts官网 <a class="markdownIt-Anchor" href="#ts官网">#</a></h2><p><a href="https://www.typescriptlang.org/index.html" target="_blank" rel="noopener">https://www.typescriptlang.org/index.html</a></p><p>目前最新的版本是<code>3.7</code></p><hr><h2 id="ts定义">ts定义 <a class="markdownIt-Anchor" href="#ts定义">#</a></h2><pre class="hljs"><code>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.
</code></pre><p><code>TypeScript</code> 是 <code>JavaScript</code> 的一个<code>超集</code>，主要提供了类型系统和对 <code>ES6</code> 的支持，它由 <code>Microsoft</code> 开发，代码开源于 <code>GitHub</code> 上。</p><hr><h2 id="优点">优点 <a class="markdownIt-Anchor" href="#优点">#</a></h2><ul><li>TypeScript可以编译为干净，简单的JavaScript代码，该代码可在任何浏览器，Node.js或任何支持ECMAScript 3（或更高版本）的JavaScript引擎中运行。</li><li>类型使JavaScript开发人员可以在开发JavaScript应用程序时使用高效的开发工具和做法，例如静态检查和代码重构。</li><li>类型是可选的，并且类型推论允许一些类型的注释对代码的静态验证产生很大的影响。</li><li>类型使您可以定义软件组件之间的接口，并深入了解现有JavaScript库的行为。</li><li>TypeScript支持最新和不断发展的JavaScript功能，包括ECMAScript 2015中的功能以及未来的提案（例如异步功能和装饰器），以帮助构建可靠的组件。</li><li>没有类型隐式转换，加上预编译报错，可以减少开发投入到测试中的时间开销。</li><li>类型强检测可以减少编写文档和开发对接的时间，TypeScript可以清楚记录每一个对象的属性，方法的参数等，有助于函数的文档化、阐明用法和减少认知开销。</li><li>增强的OO，可以用更多的设计模式，比如IOC，AOP。</li><li>在编辑器中进行开发的时候，这边就可以直接提示相关方法和属性的类型，提高开发效率。</li></ul><hr><h2 id="缺点">缺点 <a class="markdownIt-Anchor" href="#缺点">#</a></h2><ul><li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li><li>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念</li><li>ts的生态相对于js的生态圈还是小一些</li><li>而且一些工具对于ts的支持度不友好，导致使用起来非常脆，不鲁棒，强耦合于AST格式</li><li>现有的一些第三方库，基于能力扩展性考虑，很多都是自定义的类型和TS这块类型系统不兼容，导致使用体验不好。</li><li>对于短时间需要上线并且生命周期中比较短的页面项目，使用ts的时间开销成本相对较高。</li><li>集成到构建流程需要一些工作量</li></ul><hr><h2 id="注意事项">注意事项 <a class="markdownIt-Anchor" href="#注意事项">#</a></h2><blockquote><p>一般类型</p></blockquote><p>不要用真实的类型<code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Symbol</code>，或<code>Object</code> ，<code>TS</code>中用于变量类型声明的指的是，几乎从来没有在<code>JavaScript</code>代码中正确使用非基本盒装的<code>对象</code>，如<code>number</code>，<code>string</code>，<code>boolean</code>。</p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">s: <span class="hljs-built_in">String</span></span>): <span class="hljs-title">String</span></span>;
<span class="hljs-comment">/* OK */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;
</code></pre><p>注意，不要把<code>symbol</code>当为可使用的类型。</p><hr><blockquote><p>回调返回类型</p></blockquote><p>不要将返回类型<code>any</code>，用于声明其值将被忽略的回调函数，推荐使用返回类型<code>void</code>进行声明。</p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: () =&gt; <span class="hljs-built_in">any</span></span>) </span>{
  x();
}
<span class="hljs-comment">/* OK */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: () =&gt; <span class="hljs-built_in">void</span></span>) </span>{
  x();
}

</code></pre><p>因为使用返回类型<code>void</code>更为安全，因为它可以防止<code>x</code>，以未经检查的方式意外使用返回值。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: () =&gt; <span class="hljs-built_in">void</span></span>) </span>{
  <span class="hljs-keyword">var</span> k = x(); <span class="hljs-comment">// oops! meant to do something else</span>
  k.doSomething(); <span class="hljs-comment">// error, but would be OK if the return type had been 'any'</span>
}
</code></pre><hr><blockquote><p>回调中的可选参数</p></blockquote><p>除非是真的业务需求，否则不要在回调中使用<code>可选参数</code></p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-keyword">interface</span> Fetcher {
  getObject(done: <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span>, elapsedTime?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
}
<span class="hljs-comment">/* OK */</span>
<span class="hljs-keyword">interface</span> Fetcher {
  getObject(done: <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span>, elapsedTime: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
}
</code></pre><hr><blockquote><p>重载和回调</p></blockquote><p>不要编写仅在回调函数上有所不同的单独重载，请使用最大<code>Arity</code>编写单个重载</p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beforeAll</span>(<span class="hljs-params">action: () =&gt; <span class="hljs-built_in">void</span>, timeout?: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">void</span></span>;
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beforeAll</span>(<span class="hljs-params">
  action: (done: DoneFn) =&gt; <span class="hljs-built_in">void</span>,
  timeout?: <span class="hljs-built_in">number</span>
</span>): <span class="hljs-title">void</span></span>;

<span class="hljs-comment">/* OK */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beforeAll</span>(<span class="hljs-params">
  action: (done: DoneFn) =&gt; <span class="hljs-built_in">void</span>,
  timeout?: <span class="hljs-built_in">number</span>
</span>): <span class="hljs-title">void</span></span>;
</code></pre><p>因为案例中，忽略参数始终是合法的，因此不需要较短的重载。可以提供一个较短的回调，允许输入错误类型的函数，与第一个进行重载匹配。</p><hr><blockquote><p>重载函数顺序</p></blockquote><p>不要将更抽象的重载放在更具象的重载之前，重载函数顺序应该是从最具象的重载逐渐放到最抽象的重载。</p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span></span>;
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: HTMLElement</span>): <span class="hljs-title">number</span></span>;
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: HTMLDivElement</span>): <span class="hljs-title">string</span></span>;

<span class="hljs-keyword">var</span> myElem: HTMLDivElement;
<span class="hljs-keyword">var</span> x = fn(myElem); <span class="hljs-comment">// x: any, wat?</span>

<span class="hljs-comment">/* OK */</span>
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: HTMLDivElement</span>): <span class="hljs-title">string</span></span>;
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: HTMLElement</span>): <span class="hljs-title">number</span></span>;
<span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span></span>;

<span class="hljs-keyword">var</span> myElem: HTMLDivElement;
<span class="hljs-keyword">var</span> x = fn(myElem); <span class="hljs-comment">// x: string, :)</span>
</code></pre><p>因为，<code>TypeScript</code> 在解决函数调用时选择第一个匹配的重载。当较早的过载比较晚的过载<code>更抽象</code>时，之后的过载实际上是隐藏的，无法调用。</p><hr><blockquote><p>重载函数与可选参数</p></blockquote><p>如果这边可以用可选参数实现的，不要使用函数重载。</p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-keyword">interface</span> Example {
  diff(one: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;
  diff(one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span>;
  diff(one: <span class="hljs-built_in">string</span>, two: <span class="hljs-built_in">string</span>, three: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">/* OK */</span>
<span class="hljs-keyword">interface</span> Example {
  diff(one: <span class="hljs-built_in">string</span>, two?: <span class="hljs-built_in">string</span>, three?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">number</span>;
}
</code></pre><p>原因有两个：</p><ul><li><code>TypeScript</code>通过查看是否可以使用源的参数，调用目标的任何签名来解决签名兼容性， 并允许无关的参数。</li></ul><p>例如，下面代码仅在使用<code>可选参数</code>正确编写签名后，才暴露错误。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">x: (a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span>, c: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">string</span></span>) </span>{ }
<span class="hljs-keyword">const</span> x = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>[];
<span class="hljs-comment">// When written with overloads, OK -- used first overload</span>
<span class="hljs-comment">// When written with optionals, correctly an error</span>
fn(x);
<span class="hljs-comment">// Argument of type '() =&gt; never[]' is not assignable to parameter of type '(a: string, b: number, c: number) =&gt; string'.</span>
<span class="hljs-comment">//   Type 'never[]' is not assignable to type 'string'.</span>
</code></pre><ul><li>使用TypeScript的<code>严格空值检查</code>功能。由于未指定的参数<code>undefined</code>在<code>JavaScript</code>中显示，因此最好将显式值传递<code>undefined</code>给带有可选参数的函数。例如，此代码在<code>严格空值检查</code>下应该可以。</li></ul><pre class="hljs"><code><span class="hljs-keyword">var</span> x: Example;
<span class="hljs-comment">// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'</span>
<span class="hljs-comment">// When written with optionals, correctly OK</span>
x.diff(<span class="hljs-string">"something"</span>, <span class="hljs-literal">true</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-string">"hour"</span>);
</code></pre><hr><blockquote><p>重载函数与联合类型</p></blockquote><p>不要只因为参数类型，而写的函数重载。</p><pre class="hljs"><code><span class="hljs-comment">/* WRONG */</span>
<span class="hljs-keyword">interface</span> Moment {
  utcOffset(): <span class="hljs-built_in">number</span>;
  utcOffset(b: <span class="hljs-built_in">number</span>): Moment;
  utcOffset(b: <span class="hljs-built_in">string</span>): Moment;
}
<span class="hljs-comment">/* OK */</span>
<span class="hljs-keyword">interface</span> Moment {
  utcOffset(): <span class="hljs-built_in">number</span>;
  utcOffset(b: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>): Moment;
}
</code></pre><p>请注意，<code>b</code>由于签名的返回类型不同，我们在此处未设置为<code>可选</code>。</p><hr></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters09/history.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters09/learn-primitive-type.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item chapter-item-current"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters09/advantages-and-disadvantages.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#ts%E8%83%8C%E6%99%AF">ts背景</a></li>\n<li><a href="#ts%E5%AE%98%E7%BD%91">ts官网</a></li>\n<li><a href="#ts%E5%AE%9A%E4%B9%89">ts定义</a></li>\n<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>\n<li><a href="#%E7%BC%BA%E7%82%B9">缺点</a></li>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
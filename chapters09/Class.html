<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>Class - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters09/index.html" class="breadcrumb-item">第九章 ts学习</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters09/Class.html" class="breadcrumb-item">衍生类型之Class</a></div><h1 class="article-title">Class</h1><div class="article"><h2 id="基础介绍">基础介绍 <a class="markdownIt-Anchor" href="#基础介绍">#</a></h2><p>传统的<code>JavaScript</code>使用函数和基于原型的继承来构建可重用的组件，但是对于程序员来说，使用<code>类</code>继承功能，并且对象是从这些<code>类</code>中构建对象的面向对象的方法可能感到有点尴尬。</p><p>从<code>ECMAScript 2015</code>（也称为<code>ECMAScript 6</code>）开始，<code>JavaScript</code>程序员将能够使用这种面向对象的基于<code>类</code>的方法来构建其应用程序。</p><p>在<code>TypeScript</code>中，我们允许开发人员现在使用这些技术，并将其编译为可在所有主要浏览器和平台上使用的<code>JavaScript</code>，而不必等待下一个<code>JavaScript</code>版本。</p><hr><h2 id="声明">声明 <a class="markdownIt-Anchor" href="#声明">#</a></h2><h3 id="new">new <a class="markdownIt-Anchor" href="#new">#</a></h3><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> Foo {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
  }
}

Foo();
<span class="hljs-comment">// Value of type 'typeof Foo' is not callable. Did you mean to include 'new'?</span>
</code></pre><hr><h3 id="constructor">constructor <a class="markdownIt-Anchor" href="#constructor">#</a></h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。</p><p>一个类必须有<code>constructor</code>方法，如果没有<code>a</code>，一个空的<code>constructor</code>方法会被默认添加。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Foo {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
  }
}

log(<span class="hljs-keyword">new</span> Foo() <span class="hljs-keyword">instanceof</span> Foo);
<span class="hljs-comment">// false</span>
</code></pre><p><code>constructor</code>方法默认返回<code>初始化</code>完毕，对应的实例对象（即<code>this</code>），当然可以指定返回其他一个<code>对象</code>。</p><p>上面代码中，<code>constructor</code>函数返回一个全新的<code>对象</code>，结果导致实例对象不是<code>Foo</code>类的实例。</p><hr><h3 id="this">this <a class="markdownIt-Anchor" href="#this">#</a></h3><p>当我们引用<code>Class</code>中的某个<code>成员</code>时，我们会将其前置<code>this.</code>，这表示它是成员<code>访问权限</code>。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> Greeter {
  greeting: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.greeting = message;
  }
  greet() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.greeting}</span>!`</span>;
  }
}
</code></pre><hr><h3 id="属性声明">属性声明 <a class="markdownIt-Anchor" href="#属性声明">#</a></h3><p>不使用任何<code>修饰符</code>，进行<code>属性</code>声明的时候，一般会默认<code>属性</code>状态为<code>public</code>，即在<code>Class</code>内部可以通过<code>this</code>读取，<code>实例对象</code>也可以通过<code>字面量</code>的形式进行访问。</p><blockquote><p>基础声明</p></blockquote><p>不使用任何<code>修饰符</code>，直接通过<code>{{propName}}: {{propType}}</code>进行声明。同时在<code>constructor</code>方法中添加<code>属性</code>值的赋值。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    greeting: <span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-keyword">this</span>.greeting = message;
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);
log(<span class="hljs-string">`Hello, <span class="hljs-subst">${hello.greeting}</span>!`</span>);<span class="hljs-comment">// Hello, watermelon!</span>
</code></pre><p>请注意，如果在<code>constructor</code>方法中未添加<code>属性</code>值的赋值，这边就会抛出错误。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> Greeter {
    greeting: <span class="hljs-built_in">string</span>;<span class="hljs-comment">// Property 'greeting' has no initializer and is not definitely assigned in the constructor.</span>
}
</code></pre><hr><blockquote><p>赋值声明</p></blockquote><p>不使用任何<code>修饰符</code>，直接通过<code>{{propName}}: {{propType}} = {{defaultValue}}</code>进行声明，即在<code>属性声明</code>的同时，添加相关<code>默认值</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'watermelon'</span>;
}
<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
log(<span class="hljs-string">`Hello, <span class="hljs-subst">${hello.greeting}</span>!`</span>);<span class="hljs-comment">// Hello, watermelon!</span>
</code></pre><p>请注意，这个时候在<code>constructor</code>方法中未添加<code>属性</code>值的赋值，这边不会抛出错误。</p><hr><blockquote><p>特殊声明</p></blockquote><p>使用<code>TypeScript 3.8</code>，<code>TypeScript</code>支持JavaScript中<code>专用字段</code>的新语法，更多可以查看<a href="https://github.com/tc39/proposal-private-methods" target="_blank" rel="noopener">private-methods</a>和<a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">class-fields</a>，目前主要支持了<code>private-methods</code>写法，不支持<code>class-fields</code>写法，即可以在属性上添加<code>#</code>用于私有化属性简写，不能在方法上添加<code>#</code>修饰符。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    #greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'watermelon'</span>;
    greet() {
      <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.#greeting}</span>!`</span>;
    }
    #hello(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.#greeting}</span>!`</span>;
    }<span class="hljs-comment">// A method cannot be named with a private identifier.</span>
}
<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
log(hello.greet());<span class="hljs-comment">// Hello, watermelon!</span>
log(hello.#greeting);<span class="hljs-comment">// Property '#greeting' is not accessible outside class 'Greeter' because it has a private identifier.</span>
</code></pre><p>该语法内置在<code>JavaScript</code>运行时中，可以更好地保证每个<code>私有字段</code>的隔离，和<code>private</code>修饰符的作用比较像。</p><p>目前只在TS<code>3.8.0-beta</code>版中，才可以使用。</p><hr><h3 id="方法声明">方法声明 <a class="markdownIt-Anchor" href="#方法声明">#</a></h3><blockquote><p>基础声明</p></blockquote><p>由于<code>ES6</code>中对象声明的优化，所以，在<code>Class</code>中声明方法从原本的<code>{{functionName}}:function(){}</code>变为现在的<code>{{functionName}}(){}</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    greet() {
      log(<span class="hljs-string">`Hello, watermelon!`</span>);
    }
}
<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
hello.greet();<span class="hljs-comment">// Hello, watermelon!</span>

</code></pre><hr><blockquote><p>带形参的声明</p></blockquote><p>基本的语法是<code>{{functionName}}({{paramName}}: {{paramType}}){}</code>，形参相关声明和在<code>普通</code>的<code>function</code>中声明形参一样。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    greet(message: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message}</span>!`</span>);
    }
}
<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
hello.greet(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hello, watermelon!</span>
</code></pre><hr><blockquote><p>带返回值的声明</p></blockquote><p>基本的语法是<code>{{functionName}}(): {{returnType}}{}</code>，返回值相关声明和在<code>普通</code>的<code>function</code>中声明返回值一样。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    greet(): <span class="hljs-built_in">string</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, watermelon!'</span>;
    }
}
<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
log(hello.greet());<span class="hljs-comment">// Hello, watermelon!</span>
</code></pre><hr><h3 id="相关修饰符">相关修饰符 <a class="markdownIt-Anchor" href="#相关修饰符">#</a></h3><p>请注意下述五个修饰符，在<code>Class</code>中<code>属性</code>和<code>方法</code>声明中都可以同理使用。</p><blockquote><p>静态修饰符---static</p></blockquote><p><code>static</code>关键词用于创建类的<code>静态成员</code>，这些<code>静态成员</code>在类<code>本身</code>而不是<code>实例</code>上可见。</p><p>在<code>Class</code>内部和外部，都可以通过<code>{{className}}.</code>对静态成员进行访问。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">static</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">static</span> greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || Greeter.greeting}</span>!`</span>);
    }
    greetEx(message: <span class="hljs-built_in">string</span>){
      Greeter.greet(message);
    }
}
Greeter.greet();<span class="hljs-comment">// Hello, melon!</span>
log(Greeter.greeting);<span class="hljs-comment">// melon</span>

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
hello.greetEx(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hello, watermelon!</span>
</code></pre><hr><blockquote><p>只读修饰符---readonly</p></blockquote><p><code>readonly</code>关键字将<code>属性</code>设置为<code>只读</code>。请注意这个<code>修饰符</code>不能用于<code>方法</code>声明。</p><p><code>只读属性</code>必须在其声明或构造函数中进行<code>初始化</code>。</p><p>注意有且仅有在<code>constructor</code>方法的形参声明中，可以使用<code>readonly</code>关键词。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    readonly greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">readonly name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
    greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hey, watermelon!</span>
hello.greet();<span class="hljs-comment">// Hello, melon!</span>
log(hello.greeting);<span class="hljs-comment">// melon</span>

hello.greeting = <span class="hljs-string">'watermelon'</span>;<span class="hljs-comment">// Cannot assign to 'greeting' because it is a read-only property.</span>

</code></pre><p>如果未在其声明或构造函数中进行<code>初始化</code>，这边会抛出错误。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> Greeter {
    readonly greeting: <span class="hljs-built_in">string</span>;
    <span class="hljs-comment">// Property 'greeting' has no initializer and is not definitely assigned in the constructor.</span>
}

</code></pre><p>如果在实例方法的形参声明中，使用<code>readonly</code>关键词，这边会抛出错误。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-comment">// A parameter property is only allowed in a constructor implementation.</span>
    greet(readonly message: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message}</span>!`</span>);
    }
}

</code></pre><hr><blockquote><p>保护修饰符---protected</p></blockquote><p><code>protected</code>修饰符的行为很像<code>private</code>，不同的是，声明成员设置为<code>protected</code>之后，在<code>派生类</code>也中进行访问，但是，设置为<code>private</code>之后，在<code>派生类</code>中不可以进行访问。</p><p>注意有且仅有在<code>constructor</code>方法的形参声明中，可以使用<code>protected</code>关键词。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">protected</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
    <span class="hljs-keyword">protected</span> greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Greeter{
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">super</span>(name);
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hey, watermelon!</span>
hello.greet();<span class="hljs-comment">// Property 'greet' is protected and only accessible within class 'Greeter' and its subclasses.</span>
log(hello.greeting);<span class="hljs-comment">// Property 'greet' is protected and only accessible within class 'Greeter' and its subclasses.</span>

hello.greeting = <span class="hljs-string">'watermelon'</span>;<span class="hljs-comment">// Property 'greeting' is protected and only accessible within class 'Greeter' and its subclasses.</span>

<span class="hljs-keyword">const</span> littleBird = <span class="hljs-keyword">new</span> Bird(<span class="hljs-string">'melonHero'</span>);
<span class="hljs-comment">// Hey, melonHero!</span>
<span class="hljs-comment">// Hey, melon!</span>

</code></pre><p>也可以标记构造函数<code>protected</code>。这意味着该类不能在其包含的类之外<code>实例化</code>，但是可以<code>扩展</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Greeter{
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">super</span>(name);
    }
}

<span class="hljs-keyword">const</span> littleBird = <span class="hljs-keyword">new</span> Bird(<span class="hljs-string">'melonHero'</span>);<span class="hljs-comment">// Hey, melonHero!</span>

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);
<span class="hljs-comment">// Constructor of class 'Greeter' is protected and only accessible within the class declaration.</span>

</code></pre><p>如果在实例方法的形参声明中，使用<code>protected</code>关键词，这边会抛出错误。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-comment">// A parameter property is only allowed in a constructor implementation.</span>
    greet(<span class="hljs-keyword">protected</span> message: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message}</span>!`</span>);
    }
}

</code></pre><p>要使两种实例对象进行兼容赋值，如果其中一种具有<code>protected</code>成员，则另一种必须具有完全一样个数的<code>protected</code>成员，否则就会赋值不成功。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">protected</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">protected</span> name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
    <span class="hljs-keyword">protected</span> greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">class</span> Bird <span class="hljs-keyword">extends</span> Greeter{
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">super</span>(name);
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${<span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">class</span> Cat{
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
}
<span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hey, watermelon!</span>
<span class="hljs-keyword">let</span> littleBird = <span class="hljs-keyword">new</span> Bird(<span class="hljs-string">'melonHero'</span>);
<span class="hljs-keyword">let</span> littleCat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'melonHero'</span>);

hello = littleBird;
hello = littleCat;<span class="hljs-comment">// Type 'Cat' is missing the following properties from type 'Greeter': greeting, name, greet</span>

</code></pre><hr><blockquote><p>私有修饰符---private</p></blockquote><p><code>private</code>关键字将<code>属性</code>设置为<code>私有</code>，无法从其包含类的<code>外部</code>进行访问。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">private</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
    <span class="hljs-keyword">private</span> greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hey, watermelon!</span>
hello.greet();<span class="hljs-comment">// Property 'greet' is private and only accessible within class 'Greeter'.</span>
log(hello.greeting);<span class="hljs-comment">// Property 'greet' is private and only accessible within class 'Greeter'.</span>

</code></pre><p>要使两种实例对象进行兼容赋值，如果其中一种具有<code>private</code>成员，则另一种必须具有完全一样个数的<code>private</code>成员，否则就会赋值不成功。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">private</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
    <span class="hljs-keyword">private</span> greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">class</span> Cat{
    <span class="hljs-keyword">private</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
}
<span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hey, watermelon!</span>
<span class="hljs-keyword">let</span> littleCat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'melonHero'</span>);

hello = littleCat;<span class="hljs-comment">// Type 'Cat' is missing the following properties from type 'Greeter': name, greet</span>
</code></pre><hr><blockquote><p>公有修饰符---public</p></blockquote><p>在<code>TypeScript</code>中，默认情况下每个成员都是<code>public</code>状态，当然还是可以，通过<code>public</code>修饰符的明确标记成员为<code>公开成员</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">public</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) {
      log(<span class="hljs-string">`Hey, <span class="hljs-subst">${name}</span>!`</span>);
    }
    <span class="hljs-keyword">public</span> greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>.greeting}</span>!`</span>);
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">'watermelon'</span>);<span class="hljs-comment">// Hey, watermelon!</span>
hello.greet();<span class="hljs-comment">// Hello, melon!</span>
log(hello.greeting);<span class="hljs-comment">// melon</span>
</code></pre><hr><h3 id="gettersetter">getter&amp;setter <a class="markdownIt-Anchor" href="#gettersetter">#</a></h3><p><code>TypeScript</code>支持<code>getters</code>/<code>setter</code>方法，以拦截对<code>对象成员</code>的访问，这让我们可以更好地控制如何在每个对象上访问成员，强制执行一些约束。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">class</span> Greeter {
    <span class="hljs-keyword">private</span> _greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">private</span> fullGreetMaxLength:<span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>
    greet(message?: <span class="hljs-built_in">string</span>) {
      log(<span class="hljs-string">`Hello, <span class="hljs-subst">${message || <span class="hljs-keyword">this</span>._greeting}</span>!`</span>);
    }
    <span class="hljs-keyword">get</span> greeting(): <span class="hljs-built_in">string</span> {
        log(<span class="hljs-string">'now is getting greeting attr'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._greeting;
    }

    <span class="hljs-keyword">set</span> greeting(newGreet: <span class="hljs-built_in">string</span>) {
        <span class="hljs-keyword">if</span> (newGreet &amp;&amp; newGreet.length &gt; <span class="hljs-keyword">this</span>.fullGreetMaxLength) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"greet has a max length of "</span> + <span class="hljs-keyword">this</span>.fullGreetMaxLength);
        }
        <span class="hljs-keyword">this</span>._greeting = newGreet;
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
log(hello.greeting);<span class="hljs-comment">// now is getting greeting attr</span>
<span class="hljs-comment">// melon</span>

hello.greeting = <span class="hljs-string">'watermelon!!!!!!!!!!!!!!!!!!!!!!!'</span>;<span class="hljs-comment">// greet has a max length of 10</span>

</code></pre><p>如上述示例，在<code>greeting</code>属性获取和设置的时候，这边都做了相关的挟持，并且在属性赋值的时候做了长度校验。</p><p>案例中属性赋值超过了限制长度，则这边进行了错误抛出。</p><blockquote><p>注意事项</p></blockquote><p>首先，访问器要求您将编译器设置为输出<code>ECMAScript 5</code>或更高版本。不支持降级为<code>ECMAScript 3</code>。</p><p>其次，一个属性如果只写了get处理，没有写set处理，这边会自动推断该属性为readonly属性。</p><p><code>.d.ts</code>从代码中生成文件时，这很有用，因为这边编辑器会直接提示该属性无法修改。</p><hr><h3 id="抽象类声明">抽象类声明 <a class="markdownIt-Anchor" href="#抽象类声明">#</a></h3><blockquote><p>基础说明</p></blockquote><p><code>抽象类</code>是可以从中派生其他类的基类。它们可能无法直接实例化。与接口不同，抽象类可能包含其成员的实现详细信息。</p><p>该<code>abstract</code>关键字用于抽象类中定义<code>抽象类</code>以及<code>抽象方法</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Melon {
    <span class="hljs-keyword">abstract</span> makeSound(): <span class="hljs-built_in">void</span>;
    move(): <span class="hljs-built_in">void</span> {
        log(<span class="hljs-string">"roaming the earth..."</span>);
    }
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> Greeter();
log(hello.greeting);<span class="hljs-comment">// now is getting greeting attr</span>
<span class="hljs-comment">// melon</span>

hello.greeting = <span class="hljs-string">'watermelon!!!!!!!!!!!!!!!!!!!!!!!'</span>;<span class="hljs-comment">// greet has a max length of 10</span>

</code></pre><p>抽象类中标记为抽象的方法不包含实现，必须在派生类中实现。抽象方法与接口方法具有相似的语法。两者都定义了方法的签名，而没有包括方法主体。但是，抽象方法必须包含<code>abstract</code>关键字，并且可以选择包含访问修饰符。</p><hr><h2 id="抽象类和接口对比">抽象类和接口对比 <a class="markdownIt-Anchor" href="#抽象类和接口对比">#</a></h2><h3 id="基础说明">基础说明 <a class="markdownIt-Anchor" href="#基础说明">#</a></h3><blockquote><p>接口和抽象类声明的区别</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">interface</span> iDemo {
    name: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
    hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> aDemo {
    #name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">abstract</span> hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
    greet():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'hello~~~~~~~'</span>;
    }
    <span class="hljs-keyword">get</span> sex(): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'women'</span>
    }
    <span class="hljs-keyword">set</span> sex(value) {
        <span class="hljs-keyword">const</span> DEFALUT_VALUE_ARR: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">'man'</span>, <span class="hljs-string">'woman'</span>];
        DEFALUT_VALUE_ARR.indexOf(value) &gt; <span class="hljs-number">-1</span> &amp;&amp; (<span class="hljs-keyword">this</span>.sex = value);
    }
}

<span class="hljs-keyword">const</span> test01:iDemo = {name:<span class="hljs-string">'111'</span>,age:<span class="hljs-number">11</span>,hello:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'hello'</span>};

<span class="hljs-keyword">const</span> test02:aDemo = {sex:<span class="hljs-string">'woman'</span>,hello:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'hello'</span>,greet:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'greet'</span>};
<span class="hljs-comment">// Property '#name' is missing in type '{ sex: string; hello: () =&gt; string; greet: () =&gt; string; }' but required in type 'aDemo'.</span>

<span class="hljs-keyword">const</span> test03:aDemo = {<span class="hljs-string">'name'</span>:<span class="hljs-string">'melon'</span>,sex:<span class="hljs-string">'woman'</span>,hello:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'hello'</span>,greet:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'greet'</span>};
<span class="hljs-comment">// Type '{ name: string; sex: string; hello: () =&gt; string; greet: () =&gt; string; }' is not assignable to type 'aDemo'.</span>
<span class="hljs-comment">//   Object literal may only specify known properties, and ''name'' does not exist in type 'aDemo'.</span>

<span class="hljs-keyword">const</span> test04:aDemo = {<span class="hljs-string">'#name'</span>:<span class="hljs-string">'melon'</span>,sex:<span class="hljs-string">'woman'</span>,hello:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'hello'</span>,greet:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-string">'greet'</span>};
<span class="hljs-comment">// Type '{ '#name': string; sex: string; hello: () =&gt; string; greet: () =&gt; string; }' is not assignable to type 'aDemo'.</span>
<span class="hljs-comment">//   Object literal may only specify known properties, and ''#name'' does not exist in type 'aDemo'.</span>

<span class="hljs-comment">// Cannot create an instance of an abstract class.</span>
<span class="hljs-keyword">const</span> test05:aDemo = <span class="hljs-keyword">new</span> aDemo();

<span class="hljs-comment">// 'iDemo' only refers to a type, but is being used as a value here.</span>
<span class="hljs-keyword">const</span> test06:aDemo = <span class="hljs-keyword">new</span> iDemo();
</code></pre><p>可以看到</p><ul><li><code>接口</code>中只能声明字段(<code>name</code>,<code>age</code>)，而<code>抽象类</code>中可以声明具有访问器的属性(<code>sex</code>)。</li><li><code>接口</code>中字段的声明不能使用(<code>public</code>,<code>private(#)</code>,<code>static</code>,<code>readonly</code>和<code>protected</code>),而<code>抽象类</code>中声明属性是可以使用修饰符的。</li><li><code>接口</code>中声明方法是完全不可以包括具体实现，但是<code>抽象类</code>中抽象方法不可以包括具体实现，但是普通方法还是可以写具体实现的。</li><li><code>接口</code>和 <code>抽象类</code>都是不可以直接被实例化的</li><li><code>接口</code>和 <code>抽象类</code>在用于变量的类型声明之后，变量的赋值中需要包括<code>接口</code>和 <code>抽象类</code>的所有属性和方法。</li></ul><hr><blockquote><p>接口和抽象类的多重继承区别</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">interface</span> test01 {
}
<span class="hljs-keyword">interface</span> test02 {
}
<span class="hljs-keyword">class</span> test03 {

}
<span class="hljs-keyword">class</span> test04 {

}

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> aDemo {
}
<span class="hljs-keyword">class</span> iGreeter1 <span class="hljs-keyword">implements</span> test01,test02 {
}

<span class="hljs-comment">// Classes can only extend a single class.</span>
<span class="hljs-keyword">class</span> oGreeter1 <span class="hljs-keyword">extends</span> test03,test04 {
}
<span class="hljs-comment">// Classes can only extend a single class.</span>
<span class="hljs-keyword">class</span> oGreeter2 <span class="hljs-keyword">extends</span> aDemo,test01 {
}

</code></pre><p><code>implements</code>支持多重继承接口，<code>extends</code>只支持单类继承。</p><hr><blockquote><p>接口和抽象类继承属性的区别</p></blockquote><pre class="hljs"><code>
<span class="hljs-keyword">interface</span> iDemo {
    name: <span class="hljs-built_in">string</span>;
    age: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> aDemo {
    #name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'melon'</span>;
    <span class="hljs-keyword">abstract</span> sex:<span class="hljs-built_in">string</span> = <span class="hljs-string">'women'</span>;

}
<span class="hljs-keyword">class</span> iGreeter <span class="hljs-keyword">implements</span> iDemo {
    <span class="hljs-comment">// Class 'iGreeter' incorrectly implements interface 'iDemo'.</span>
    <span class="hljs-comment">// Type 'iGreeter' is missing the following properties from type 'iDemo': name, age</span>
    hello(name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${age}</span> <span class="hljs-subst">${name || <span class="hljs-keyword">this</span>.name}</span> `</span>;
        <span class="hljs-comment">// Property 'name' does not exist on type 'iGreeter'.</span>
    }
}
<span class="hljs-keyword">class</span> oGreeter <span class="hljs-keyword">extends</span> aDemo {
    <span class="hljs-comment">// Non-abstract class 'oGreeter' does not implement inherited abstract member 'sex' from class 'aDemo'.</span>
    hello(name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${age}</span> <span class="hljs-subst">${name || <span class="hljs-keyword">this</span>.name}</span> `</span>;
        <span class="hljs-comment">//Property 'name' does not exist on type 'oGreeter'. Did you mean '#name'?</span>
    }
    greet():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.sex}</span> <span class="hljs-subst">${name || <span class="hljs-keyword">this</span>.#name}</span> `</span>;
        <span class="hljs-comment">//Property '#name' is not accessible outside class 'aDemo' because it has a private identifier.</span>
    }
}
</code></pre><p>可以看到</p><ul><li>类继承<code>接口</code>，<code>接口</code>中的字段一定要在类中声明的，否则这边就会报错，说明<code>missing the following properties</code>。</li><li>类继承<code>抽象类</code>，<code>抽象类</code>中声明的普通属性，类中可以不用强制声明，但是在<code>抽象类</code>中声明的抽象属性，类中必须要进行声明。</li><li>类在继承<code>接口</code>和<code>抽象类</code>中属性的时候，类型声明都需要和原有保持一致，否则就会报错<code>not assignable to the same property in base type</code>。</li><li>类在继承<code>抽象类</code>的时候，如果没有按照规范实现属性声明，但是在类方法中访问对应的抽象属性，不会报错，但是如果是继承<code>接口</code>，未按照<code>接口</code>字段继承配置，在类方法中访问对应的属性，是会抛出错误的。</li></ul><hr><blockquote><p>接口和抽象类声明方法的区别</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">interface</span> iDemo {
    hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
    greet(name: <span class="hljs-built_in">string</span>):<span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">class</span> iGreeter1 <span class="hljs-keyword">implements</span> iDemo {
    <span class="hljs-comment">//Class 'iGreeter1' incorrectly implements interface 'iDemo'.</span>
    <span class="hljs-comment">//Type 'iGreeter1' is missing the following properties from type 'iDemo': hello, greet</span>
    helloEx(name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">string</span>) {
    }
    greetEx():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello melon~~~`</span>;
    }
}
<span class="hljs-keyword">class</span> iGreeter2 <span class="hljs-keyword">implements</span> iDemo {
    <span class="hljs-comment">// Property 'hello' in type 'iGreeter' is not assignable to the same property in base type 'iDemo'.</span>
    <span class="hljs-comment">// Type '(name: string, age: string) =&gt; void' is not assignable to type '(name: string) =&gt; string'.</span>
    hello(name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">string</span>) {
    }
    greetEx():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.greet()}</span> melon~~~`</span>;
    }
}
<span class="hljs-keyword">class</span> iGreeter3 <span class="hljs-keyword">implements</span> iDemo {
    hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${name}</span>`</span>;
    }
    greet():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello melon~~~`</span>;
    }
}
</code></pre><p>可以看到类在继承<code>接口</code>的时候</p><ul><li><code>接口</code>中的方法不必要全部都实现，但是如果一个方法都不实现，这边会报错。</li><li><code>接口</code>中的方法如果规定了形参个数和类型，类在继承实现的时候，需要严格按照规范实现，否则会报错。</li><li><code>接口</code>中的方法如果未规定返回值类型，或者规定的返回类型为<code>void</code>，则在继承实现的时候，可以修改形参个数，类型和返回值类型。</li></ul><pre class="hljs"><code><span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> aDemo {
    <span class="hljs-keyword">abstract</span> hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;
    greet(name: <span class="hljs-built_in">string</span>):<span class="hljs-built_in">void</span>{
        log(<span class="hljs-string">`hello`</span>);
    }

}
<span class="hljs-keyword">class</span> oGreeter1 <span class="hljs-keyword">extends</span> aDemo {
    <span class="hljs-comment">// Non-abstract class 'oGreeter' does not implement inherited abstract member 'hello' from class 'aDemo'.</span>
    helloEx(name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">string</span>){
    }
    greetEx():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.greet()}</span> melon~~~`</span>;
    }
}
<span class="hljs-keyword">class</span> oGreeter2 <span class="hljs-keyword">extends</span> aDemo {
    <span class="hljs-comment">// Property 'hello' in type 'oGreeter' is not assignable to the same property in base type 'aDemo'.</span>
    <span class="hljs-comment">// Type '(name: string, age: string) =&gt; void' is not assignable to type '(name: string) =&gt; string'.</span>
    hello(name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">string</span>){
    }
    greetEx():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.greet()}</span> melon~~~`</span>;
    }
}
<span class="hljs-keyword">class</span> oGreeter3 <span class="hljs-keyword">extends</span> aDemo {
    hello(name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello <span class="hljs-subst">${name}</span>`</span>;
    }
    greet():<span class="hljs-built_in">string</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`hello melon~~~`</span>;
    }
}
</code></pre><p>可以看到类在继承<code>抽象类</code>的时候</p><ul><li><code>抽象类</code>中的方法不必要全部都实现，但是抽象方法必须实现，否则这边会报错。</li><li><code>抽象类</code>中的方法如果规定了形参个数和类型，类在继承实现的时候，需要严格按照规范实现，否则会报错。</li><li><code>抽象类</code>中的方法如果未规定返回值类型，或者规定的返回类型为<code>void</code>，则在继承实现的时候，可以修改形参个数，类型和返回值类型。</li><li><code>抽象类</code>里可以没有<code>抽象方法</code></li><li>如果一个类里有<code>抽象方法</code>，那么这个类只能是<code>抽象类</code></li><li><code>抽象方法</code>要被实现，所以不能是静态的，也不能是私有的。</li></ul><hr><h3 id="总结">总结 <a class="markdownIt-Anchor" href="#总结">#</a></h3><blockquote><p>相同点：</p></blockquote><ul><li>都是抽象类型。</li><li>都可以有实现方法。</li><li>都可以不需要实现类或者继承者去实现所有方法。</li><li><code>抽象类</code>和<code>接口</code>都不能直接通过<code>new</code>关键词来进行实例化。</li><li>如果变量类型来进行实例化，变量必须实现所有<code>接口</code>或者<code>抽象类</code>的属性和方法。</li><li>在继承<code>接口</code>和<code>抽象类</code>方法时，除了规定了返回值为<code>void</code>的方法可以进行自定义实现，其他继承的方法必须按照规范实现。</li></ul><blockquote><p>不同点：</p></blockquote><ul><li><code>接口</code>中只能声明没有访问器的字段，<code>抽象类</code>中可以声明有访问器的属性。</li><li><code>接口</code>中字段声明不可以使用相关<code>修饰符</code>，抽象类中属性声明可以，并且属性还可以赋予默认值。</li><li><code>接口</code>中的方法在继承的时候不会强制显示必须都要实现，但是<code>抽象类</code>中的抽象方法在继承的时候，必须都要实现。</li><li><code>抽象类</code>不可以多重继承，<code>接口</code>可以。</li></ul><hr></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters09/interface.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters09/ts-util.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item chapter-item-current"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters09/Class.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D">基础介绍</a></li>\n<li><a href="#%E5%A3%B0%E6%98%8E">声明</a>\n<ul>\n<li><a href="#new">new</a></li>\n<li><a href="#constructor">constructor</a></li>\n<li><a href="#this">this</a></li>\n<li><a href="#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E">属性声明</a></li>\n<li><a href="#%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E">方法声明</a></li>\n<li><a href="#%E7%9B%B8%E5%85%B3%E4%BF%AE%E9%A5%B0%E7%AC%A6">相关修饰符</a></li>\n<li><a href="#gettersetter">getter&amp;setter</a></li>\n<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%A3%B0%E6%98%8E">抽象类声明</a></li>\n</ul>\n</li>\n<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%AF%B9%E6%AF%94">抽象类和接口对比</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E">基础说明</a></li>\n<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
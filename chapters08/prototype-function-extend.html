<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>原型对象方法扩展 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters08/index.html" class="breadcrumb-item">第八章 数组的扩展</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters08/prototype-function-extend.html" class="breadcrumb-item">原型对象方法扩展</a></div><h1 class="article-title">原型对象方法扩展</h1><div class="article"><h2 id="arrayfrom"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from()</a> <a class="markdownIt-Anchor" href="#arrayfrom">#</a></h2><h3 id="基础语法">基础语法 <a class="markdownIt-Anchor" href="#基础语法">#</a></h3><pre class="hljs"><code><span class="hljs-built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])
</code></pre><hr><h3 id="参数说明">参数说明 <a class="markdownIt-Anchor" href="#参数说明">#</a></h3><blockquote><p>arrayLike</p></blockquote><p>想要转换成数组的伪数组对象或可迭代对象。</p><blockquote><p>mapFn (可选参数)</p></blockquote><p>如果指定了该参数，新数组中的每个元素会执行该回调函数。</p><blockquote><p>thisArg (可选参数)</p></blockquote><p>可选参数，执行回调函数 <code>mapFn</code> 时 <code>this</code> 对象。</p><hr><h3 id="返回值说明">返回值说明 <a class="markdownIt-Anchor" href="#返回值说明">#</a></h3><p>一个新的数组实例</p><hr><h3 id="详细说明">详细说明 <a class="markdownIt-Anchor" href="#详细说明">#</a></h3><p><code>Array.from()</code> 方法用于将两类对象转为真正的数组：类似数组的对象（<code>array-like object</code>）和可遍历（<code>iterable</code>）的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）。实例。</p><p><code>Array.from()</code> 可以通过以下方式来创建数组对象：</p><ul><li>伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）</li><li>可迭代对象（可以获取对象中的元素,如 <code>Map</code>和 <code>Set</code> 等）</li></ul><p><code>Array.from()</code> 方法有一个可选参数 <code>mapFn</code>，让你可以在最后生成的数组上再执行一次 <code>map</code> 方法后再返回。也就是说 <code>Array.from(obj, mapFn, thisArg)</code> 就相当于 <code>Array.from(obj).map(mapFn, thisArg)</code>, 除非创建的不是可用的中间数组。 这对一些数组的子类,如 <code>typed arrays</code> 来说很重要, 因为中间数组的值在调用 <code>map()</code> 时需要是适当的类型。</p><p><code>from()</code> 的 <code>length</code> 属性为 1 ，即<code>Array.from.length = 1</code>。</p><p>在 <code>ES2015</code> 中， <code>Class</code> 语法允许我们为内置类型（比如 <code>Array</code>）和自定义类新建子类（比如叫 <code>SubArray</code>）。</p><p>这些子类也会继承父类的静态方法，比如 <code>SubArray.from()</code>，调用该方法后会返回子类 <code>SubArray</code> 的一个实例，而不是 <code>Array</code> 的实例。</p><hr><h3 id="与扩展运算符区别">与扩展运算符区别 <a class="markdownIt-Anchor" href="#与扩展运算符区别">#</a></h3><p>扩展运算符（<code>...</code>）也可以将某些<code>数据结构</code>转为<code>数组</code>。</p><pre class="hljs"><code><span class="hljs-comment">// arguments对象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> args = [...arguments];
}

<span class="hljs-comment">// NodeList对象</span>
[...document.querySelectorAll(<span class="hljs-string">'div'</span>)]
</code></pre><p>扩展运算符背后调用的是<code>遍历器接口</code>（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。</p><p><code>Array.from</code>方法还支持<code>类似数组</code>的对象。所谓<code>类似数组</code>的对象，本质特征只有一点，即必须有<code>length</code>属性。</p><p>因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为<code>数组</code>，而此时<code>扩展运算符</code>就无法转换。</p><pre class="hljs"><code><span class="hljs-built_in">Array</span>.from({ <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [ undefined, undefined, undefined ]</span>
</code></pre><p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。<code>扩展运算符</code>转换不了这个对象。</p><hr><h3 id="案例">案例 <a class="markdownIt-Anchor" href="#案例">#</a></h3><blockquote><p>Array from a String</p></blockquote><pre class="hljs"><code><span class="hljs-built_in">Array</span>.from(<span class="hljs-string">'foo'</span>); 
<span class="hljs-comment">// ["f", "o", "o"]</span>
</code></pre><hr><blockquote><p>Array from a Set</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-built_in">window</span>]); 
<span class="hljs-built_in">Array</span>.from(s); 
<span class="hljs-comment">// ["foo", window]</span>
</code></pre><hr><blockquote><p>Array from a Map</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>]]);
<span class="hljs-built_in">Array</span>.from(m); 
<span class="hljs-comment">// [[1, 2], [2, 4], [4, 8]]</span>
</code></pre><hr><blockquote><p>Array from an Array-like object (arguments)</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">arrayLike</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(arrayLike);
}

<span class="hljs-keyword">const</span> arrayLike = {
    <span class="hljs-string">'0'</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-string">'1'</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-string">'2'</span>: <span class="hljs-string">'c'</span>,
    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>
};

f(arrayLike);

<span class="hljs-comment">// ["a", "b", "c"]</span>
</code></pre><hr><blockquote><p>Array.from an DOM NodeList</p></blockquote><p>实际应用中，常见的类似数组的对象是 <code>DOM</code> 操作返回的 <code>NodeList</code> 集合。<code>Array.from</code>可以将它们转为真正的<code>数组</code>。</p><pre class="hljs"><code><span class="hljs-comment">// NodeList对象</span>
<span class="hljs-keyword">let</span> ps = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'p'</span>);
<span class="hljs-built_in">Array</span>.from(ps).filter(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> p.textContent.length &gt; <span class="hljs-number">100</span>;
});
</code></pre><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>filter</code>方法。</p><hr><blockquote><p>Array.from an Array</p></blockquote><p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p><pre class="hljs"><code><span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-comment">// [1, 2, 3]</span>
</code></pre><hr><blockquote><p>在Array.from中使用箭头函数</p></blockquote><pre class="hljs"><code><span class="hljs-comment">// Using an arrow function as the map function to</span>
<span class="hljs-comment">// manipulate the elements</span>
<span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], x =&gt; x + x);  
<span class="hljs-comment">// x =&gt; x + x代表这是一个函数，只是省略了其他的定义，这是一种Lambda表达式的写法</span>
<span class="hljs-comment">// 箭头的意思表示从当前数组中取出一个值，然后自加，并将返回的结果添加到新数组中    </span>
<span class="hljs-comment">// [2, 4, 6]</span>


<span class="hljs-comment">// Generate a sequence of numbers</span>
<span class="hljs-comment">// Since the array is initialized with `undefined` on each position,</span>
<span class="hljs-comment">// the value of `v` below will be `undefined`</span>
<span class="hljs-built_in">Array</span>.from({<span class="hljs-attr">length</span>: <span class="hljs-number">5</span>}, (v, i) =&gt; i);
<span class="hljs-comment">// [0, 1, 2, 3, 4]</span>
</code></pre><hr><blockquote><p>数组去重合并</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params"></span>)</span>{ 
    <span class="hljs-keyword">let</span> arr = [].concat.apply([], <span class="hljs-built_in">arguments</span>);  <span class="hljs-comment">//没有去重复的新数组 </span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr));
} 

<span class="hljs-keyword">var</span> m = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], n = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]; 
<span class="hljs-built_in">console</span>.log(combine(m,n));                     <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre><hr><blockquote><p>返回各种数据的类型</p></blockquote><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">typesOf</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>, value =&gt; <span class="hljs-keyword">typeof</span> value)
}
typesOf(<span class="hljs-literal">null</span>, [], <span class="hljs-literal">NaN</span>)
<span class="hljs-comment">// ['object', 'object', 'number']</span>
</code></pre><hr><h3 id="polyfill">Polyfill <a class="markdownIt-Anchor" href="#polyfill">#</a></h3><p><code>ECMA-262 第六版</code>标准添加了 <code>Array.from</code> 。有些实现中可能尚未包括在其中。你可以通过在脚本前添加如下内容作为替代方法，以使用未原生支持的 <code>Array.from</code> 方法。</p><p>该算法按照 <code>ECMA-262 第六版</code>中的规范实现，并假定 <code>Object</code> 和 <code>TypeError</code> 有其本身的值， <code>callback.call</code> 对应 <code>Function.prototype.call</code> 。</p><p>此外，鉴于无法使用 <code>Polyfill</code> 实现真正的的迭代器，该实现不支持规范中定义的<code>泛型可迭代</code>元素。</p><pre class="hljs"><code><span class="hljs-comment">// Production steps of ECMA-262, Edition 6, 22.1.2.1</span>
<span class="hljs-comment">// Reference: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.from) {
  <span class="hljs-built_in">Array</span>.from = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> toStr = <span class="hljs-built_in">Object</span>.prototype.toString;
    <span class="hljs-keyword">var</span> isCallable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">'function'</span> || toStr.call(fn) === <span class="hljs-string">'[object Function]'</span>;
    };
    <span class="hljs-keyword">var</span> toInteger = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> number = <span class="hljs-built_in">Number</span>(value);
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(number)) { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
      <span class="hljs-keyword">if</span> (number === <span class="hljs-number">0</span> || !<span class="hljs-built_in">isFinite</span>(number)) { <span class="hljs-keyword">return</span> number; }
      <span class="hljs-keyword">return</span> (number &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>) * <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.abs(number));
    };
    <span class="hljs-keyword">var</span> maxSafeInteger = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> toLength = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> len = toInteger(value);
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(len, <span class="hljs-number">0</span>), maxSafeInteger);
    };

    <span class="hljs-comment">// The length property of the from method is 1.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">from</span>(<span class="hljs-params">arrayLike<span class="hljs-regexp">/*, mapFn, thisArg */</span></span>) </span>{
      <span class="hljs-comment">// 1. Let C be the this value.</span>
      <span class="hljs-keyword">var</span> C = <span class="hljs-keyword">this</span>;

      <span class="hljs-comment">// 2. Let items be ToObject(arrayLike).</span>
      <span class="hljs-keyword">var</span> items = <span class="hljs-built_in">Object</span>(arrayLike);

      <span class="hljs-comment">// 3. ReturnIfAbrupt(items).</span>
      <span class="hljs-keyword">if</span> (arrayLike == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Array.from requires an array-like object - not null or undefined"</span>);
      }

      <span class="hljs-comment">// 4. If mapfn is undefined, then let mapping be false.</span>
      <span class="hljs-keyword">var</span> mapFn = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] : <span class="hljs-keyword">void</span> <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">var</span> T;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mapFn !== <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-comment">// 5. else      </span>
        <span class="hljs-comment">// 5. a If IsCallable(mapfn) is false, throw a TypeError exception.</span>
        <span class="hljs-keyword">if</span> (!isCallable(mapFn)) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Array.from: when provided, the second argument must be a function'</span>);
        }

        <span class="hljs-comment">// 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>) {
          T = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>];
        }
      }

      <span class="hljs-comment">// 10. Let lenValue be Get(items, "length").</span>
      <span class="hljs-comment">// 11. Let len be ToLength(lenValue).</span>
      <span class="hljs-keyword">var</span> len = toLength(items.length);

      <span class="hljs-comment">// 13. If IsConstructor(C) is true, then</span>
      <span class="hljs-comment">// 13. a. Let A be the result of calling the [[Construct]] internal method </span>
      <span class="hljs-comment">// of C with an argument list containing the single item len.</span>
      <span class="hljs-comment">// 14. a. Else, Let A be ArrayCreate(len).</span>
      <span class="hljs-keyword">var</span> A = isCallable(C) ? <span class="hljs-built_in">Object</span>(<span class="hljs-keyword">new</span> C(len)) : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);

      <span class="hljs-comment">// 16. Let k be 0.</span>
      <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 17. Repeat, while k &lt; len… (also steps a - h)</span>
      <span class="hljs-keyword">var</span> kValue;
      <span class="hljs-keyword">while</span> (k &lt; len) {
        kValue = items[k];
        <span class="hljs-keyword">if</span> (mapFn) {
          A[k] = <span class="hljs-keyword">typeof</span> T === <span class="hljs-string">'undefined'</span> ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } <span class="hljs-keyword">else</span> {
          A[k] = kValue;
        }
        k += <span class="hljs-number">1</span>;
      }
      <span class="hljs-comment">// 18. Let putStatus be Put(A, "length", len, true).</span>
      A.length = len;
      <span class="hljs-comment">// 20. Return A.</span>
      <span class="hljs-keyword">return</span> A;
    };
  }());
}
</code></pre><hr><h2 id="arrayof"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of" target="_blank" rel="noopener">Array.of()</a> <a class="markdownIt-Anchor" href="#arrayof">#</a></h2><h3 id="基础语法-1">基础语法 <a class="markdownIt-Anchor" href="#基础语法-1">#</a></h3><pre class="hljs"><code><span class="hljs-built_in">Array</span>.of(element0[, element1[, ...[, elementN]]])
</code></pre><hr><h3 id="参数说明-1">参数说明 <a class="markdownIt-Anchor" href="#参数说明-1">#</a></h3><blockquote><p>elementN</p></blockquote><p>任意个参数，将按顺序成为返回数组中的元素。</p><hr><h3 id="返回值说明-1">返回值说明 <a class="markdownIt-Anchor" href="#返回值说明-1">#</a></h3><p>新的 Array 实例。</p><hr><h3 id="详细描述">详细描述 <a class="markdownIt-Anchor" href="#详细描述">#</a></h3><p><code>Array.of()</code> 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p><p><code>Array.of()</code> 和 <code>Array</code> 构造函数之间的区别在于处理整数参数：</p><ul><li><code>Array.of(7)</code> 创建一个具有单个元素 7 的数组</li><li><code>Array(7)</code> 创建一个长度为<code>7</code>的空数组（注意：这是指一个有7个空位的数组，而不是由7个<code>undefined</code>组成的数组）。</li></ul><pre class="hljs"><code><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>);       <span class="hljs-comment">// [7]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>);          <span class="hljs-comment">// [ , , , , , , ]</span>
<span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre><p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 <code>2</code> 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的<code>重载</code>。它的行为非常统一。</p><pre class="hljs"><code><span class="hljs-built_in">Array</span>.of() <span class="hljs-comment">// []</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// [undefined]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 2]</span>
</code></pre><p><code>Array.of</code>总是返回<code>参数值</code>组成的<code>数组</code>。如果没有参数，就返回一个<code>空数组</code>。</p><p>此函数是<code>ECMAScript 2015</code>标准的一部分。详见 <a href="https://gist.github.com/rwaldron/1074126" target="_blank" rel="noopener"><code>Array.of</code></a> 和 <a href="https://gist.github.com/rwaldron/1074126" target="_blank" rel="noopener"><code>Array.from proposal</code></a> 和 <a href="https://gist.github.com/rwaldron/3186576" target="_blank" rel="noopener"><code>Array.of polyfill</code></a>。</p><hr><h3 id="案例-1">案例 <a class="markdownIt-Anchor" href="#案例-1">#</a></h3><pre class="hljs"><code><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>);         <span class="hljs-comment">// [1]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [undefined]</span>
</code></pre><hr><h3 id="polyfill-1">polyfill <a class="markdownIt-Anchor" href="#polyfill-1">#</a></h3><p>如果原生不支持的话，在其他代码之前执行以下代码会创建 <code>Array.of()</code> 。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.of) {
  <span class="hljs-built_in">Array</span>.of = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
  };
}
</code></pre><hr></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters08/extension-operator.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters08/instance-function-extend.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item chapter-item-current"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters08/prototype-function-extend.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#arrayfrom">Array.from()</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">基础语法</a></li>\n<li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li>\n<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AF%B4%E6%98%8E">返回值说明</a></li>\n<li><a href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E">详细说明</a></li>\n<li><a href="#%E4%B8%8E%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8C%BA%E5%88%AB">与扩展运算符区别</a></li>\n<li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li>\n<li><a href="#polyfill">Polyfill</a></li>\n</ul>\n</li>\n<li><a href="#arrayof">Array.of()</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-1">基础语法</a></li>\n<li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-1">参数说明</a></li>\n<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AF%B4%E6%98%8E-1">返回值说明</a></li>\n<li><a href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0">详细描述</a></li>\n<li><a href="#%E6%A1%88%E4%BE%8B-1">案例</a></li>\n<li><a href="#polyfill-1">polyfill</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>const 命令 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters02/index.html" class="breadcrumb-item">第二章 let和const命令</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters02/const.html" class="breadcrumb-item">const 命令</a></div><h1 class="article-title">const 命令</h1><div class="article"><h2 id="基本用法">基本用法 <a class="markdownIt-Anchor" href="#基本用法">#</a></h2><p><code>const</code>声明一个<code>只读</code>的<code>常量</code>。</p><p>一旦声明，<code>常量</code>的值就不能<code>改变</code>。</p><pre class="hljs"><code>
<span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.1415</span>;
PI <span class="hljs-comment">// 3.1415</span>

PI = <span class="hljs-number">3</span>;
<span class="hljs-comment">// TypeError: Assignment to constant variable.</span>
</code></pre><p>上面代码表明改变常量的值会报错。</p><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><hr><h2 id="实现原理">实现原理 <a class="markdownIt-Anchor" href="#实现原理">#</a></h2><p><code>const</code>实际上保证的，并不是<code>变量</code>的<code>值</code>不得<code>改动</code>，而是<code>变量</code>指向的那个<code>内存地址</code>所保存的<code>数据</code>不得<code>改动</code>。</p><p>对于简单类型的数据（<code>数值</code>、<code>字符串</code>、<code>布尔值</code>），<code>值</code>就保存在<code>变量</code>指向的那个<code>内存地址</code>，因此等同于<code>常量</code>。</p><p>但对于复合类型的数据（主要是<code>对象</code>和<code>数组</code>），<code>变量</code>指向的<code>内存地址</code>，保存的只是一个指向<code>实际数据</code>的<code>指针</code>，<code>const</code>只能保证这个<code>指针</code>是<code>固定</code>的（即总是指向另一个<code>固定</code>的<code>地址）</code>，至于它指向的<code>数据结构</code>是不是<code>可变</code>的，就完全不能控制了。</p><p>因此，将一个对象声明为<code>常量</code>必须非常小心。</p><blockquote><p>声明对象常量</p></blockquote><pre class="hljs"><code>
<span class="hljs-keyword">const</span> foo = {};

<span class="hljs-comment">// 为 foo 添加一个属性，可以成功</span>
foo.prop = <span class="hljs-number">123</span>;
foo.prop <span class="hljs-comment">// 123</span>

<span class="hljs-comment">// 将 foo 指向另一个对象，就会报错</span>
foo = {}; <span class="hljs-comment">// TypeError: "foo" is read-only</span>
</code></pre><p>上面代码中，<code>常量foo</code>储存的是一个<code>地址</code>，这个<code>地址</code>指向一个<code>对象</code>。</p><p><code>不可变</code>的只是这个<code>地址</code>，即不能把<code>foo</code>指向另一个<code>地址</code>，但<code>对象</code>本身是<code>可变</code>的，所以依然可以为其添加<code>新属性</code>。</p><hr><blockquote><p>声明数组常量</p></blockquote><pre class="hljs"><code>
<span class="hljs-keyword">const</span> a = [];
a.push(<span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// 可执行</span>
a.length = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 可执行</span>
a = [<span class="hljs-string">'Dave'</span>];    <span class="hljs-comment">// 报错</span>
</code></pre><p>上面代码中，常量<code>a</code>是一个数组，这个<code>数组</code>本身是可写的，但是如果将另一个<code>数组</code>赋值给<code>a</code>，就会报错。</p><hr><blockquote><p>冻结对象案例</p></blockquote><p>如果真的想将对象<code>冻结</code>，应该使用<code>Object.freeze</code>方法。</p><pre class="hljs"><code>
<span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">Object</span>.freeze({});

<span class="hljs-comment">// 常规模式时，下面一行不起作用；</span>
<span class="hljs-comment">// 严格模式时，该行会报错</span>
foo.prop = <span class="hljs-number">123</span>;
</code></pre><p>上面代码中，常量<code>foo</code>指向一个<code>冻结</code>的<code>对象</code>，所以添加新属性不起作用，<code>严格模式</code>时还会报错。</p><p>除了将<code>对象</code>本身<code>冻结</code>，<code>对象</code>的<code>属性</code>也应该<code>冻结</code>。</p><p>下面是一个将对象彻底冻结的函数。</p><pre class="hljs"><code>
<span class="hljs-keyword">var</span> constantize = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
  <span class="hljs-built_in">Object</span>.freeze(obj);
  <span class="hljs-built_in">Object</span>.keys(obj).forEach( <span class="hljs-function">(<span class="hljs-params">key, i</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">'object'</span> ) {
      constantize( obj[key] );
    }
  });
};
</code></pre><hr><h2 id="注意事项">注意事项 <a class="markdownIt-Anchor" href="#注意事项">#</a></h2><h3 id="不允许声明不赋值">不允许声明不赋值 <a class="markdownIt-Anchor" href="#不允许声明不赋值">#</a></h3><pre class="hljs"><code>
<span class="hljs-keyword">const</span> foo;
<span class="hljs-comment">// SyntaxError: Missing initializer in const declaration</span>
</code></pre><p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p><hr><h3 id="不存在变量提升">不存在变量提升 <a class="markdownIt-Anchor" href="#不存在变量提升">#</a></h3><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的<code>块级作用域</code>内有效。</p><pre class="hljs"><code>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> MAX = <span class="hljs-number">5</span>;
}

MAX <span class="hljs-comment">// Uncaught ReferenceError: MAX is not defined</span>
</code></pre><hr><h3 id="暂时性死区问题">暂时性死区问题 <a class="markdownIt-Anchor" href="#暂时性死区问题">#</a></h3><p><code>const</code>命令声明的常量也是<code>不提升</code>，同样存在<code>暂时性死区</code>，只能在<code>声明</code>的位置后面使用。</p><pre class="hljs"><code>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-built_in">console</span>.log(MAX); <span class="hljs-comment">// ReferenceError</span>
  <span class="hljs-keyword">const</span> MAX = <span class="hljs-number">5</span>;
}
</code></pre><p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p><hr><h3 id="不允许重复声明">不允许重复声明 <a class="markdownIt-Anchor" href="#不允许重复声明">#</a></h3><p><code>const</code>声明的常量，也与<code>let</code>一样<code>不可重复声明</code>。</p><pre class="hljs"><code>
<span class="hljs-keyword">var</span> message = <span class="hljs-string">"Hello!"</span>;
<span class="hljs-keyword">let</span> age = <span class="hljs-number">25</span>;

<span class="hljs-comment">// 以下两行都会报错</span>
<span class="hljs-keyword">const</span> message = <span class="hljs-string">"Goodbye!"</span>;
<span class="hljs-keyword">const</span> age = <span class="hljs-number">30</span>;
</code></pre><hr><h3 id="线程安全性">线程安全性 <a class="markdownIt-Anchor" href="#线程安全性">#</a></h3><p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在<code>全局环境</code>，不应该设置<code>变量</code>，只应设置<code>常量</code>。</p><p><code>const</code>优于<code>let</code>有几个原因。</p><ul><li><code>const</code>可以提醒阅读程序的人，这个变量不应该改变。</li><li><code>const</code>比较符合<code>函数式</code>编程思想，运算不改变值，只是新建值，而且这样也有利于将来的<code>分布式</code>运算。</li></ul><p>最后一个原因是 <code>JavaScript</code> 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实<code>是编译器</code>内部的处理不同。</p><pre class="hljs"><code><span class="hljs-comment">// bad</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;

<span class="hljs-comment">// good</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>;

<span class="hljs-comment">// best</span>
<span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
</code></pre><hr><blockquote><p><code>const</code>声明<code>常量</code>还有两个好处</p></blockquote><ul><li><code>阅读代码</code>的人立刻会意识到不应该修改这个值。</li><li>防止了无意间<code>修改变量</code>值所导致的错误。</li></ul><p>所有的<code>函数</code>都应该设置为<code>常量</code>，避免污染<code>顶级对象</code>属性值。</p><p>长远来看，<code>JavaScript</code> 可能会有<code>多线程</code>的实现（比如 <code>Intel</code> 公司的 <code>River Trail</code> 那一类的项目），这时<code>let</code>表示的<code>变量</code>，只应出现在<code>单线程</code>运行的代码中，不能是<code>多线程</code>共享的，这样有利于保证<code>线程安全</code>。</p><hr></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters02/let.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters02/statement-details.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item chapter-item-current"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters02/const.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>\n<li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">实现原理</a></li>\n<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a>\n<ul>\n<li><a href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E5%A3%B0%E6%98%8E%E4%B8%8D%E8%B5%8B%E5%80%BC">不允许声明不赋值</a></li>\n<li><a href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">不存在变量提升</a></li>\n<li><a href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E9%97%AE%E9%A2%98">暂时性死区问题</a></li>\n<li><a href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E">不允许重复声明</a></li>\n<li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7">线程安全性</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
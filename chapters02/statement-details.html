<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>语句进阶说明 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters02/index.html" class="breadcrumb-item">第二章 let和const命令</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters02/statement-details.html" class="breadcrumb-item">语句进阶说明</a></div><h1 class="article-title">语句进阶说明</h1><div class="article"><p><code>JavaScript</code> 遵循了一般编程语言的<code>语句 - 表达式</code>结构，多数编程语言都是这样设计的。</p><p>在 <code>JavaScript</code> 标准中，把语句分成了两种：<code>声明</code>和<code>语句</code>，这里主要分为了<code>普通型语句</code>和<code>声明型语句</code>。</p><h2 id="普通型语句">普通型语句 <a class="markdownIt-Anchor" href="#普通型语句">#</a></h2><h3 id="语句块">语句块 <a class="markdownIt-Anchor" href="#语句块">#</a></h3><p>如果简单理解，语句块就是一对大括号。</p><pre class="hljs"><code>{
    <span class="hljs-keyword">var</span> x, y;
    x = <span class="hljs-number">10</span>;
    y = <span class="hljs-number">20</span>;
}

</code></pre><p><code>语句块</code>的意义和好处在于：可以把<code>多行语句</code>视为同一行语句，这样，<code>if</code>、<code>for</code> 等语句定义起来就比较简单了。</p><p>不过，需要注意的是，<code>语句块</code>会产生<code>作用域</code>。</p><pre class="hljs"><code>{
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;
}
<span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 报错</span>

</code></pre><p>因为 <code>let</code> 声明，仅仅对<code>语句块</code>作用域生效，于是在<code>语句块</code>外试图访问语句块内的变量 <code>x</code> 就会<code>报错</code>。</p><hr><h3 id="空语句">空语句 <a class="markdownIt-Anchor" href="#空语句">#</a></h3><p><code>空语句</code>就是一个独立的<code>分号</code>，实际上没什么大用 ，<code>空语句</code>的存在仅仅是从<code>语言设计</code>完备性的角度考虑，允许插入多个<code>分号</code>而不抛出错误。</p><pre class="hljs"><code>;

</code></pre><hr><h3 id="控制型语句">控制型语句 <a class="markdownIt-Anchor" href="#控制型语句">#</a></h3><h4 id="if语句">if语句 <a class="markdownIt-Anchor" href="#if语句">#</a></h4><p><code>if 语句</code>的作用是，在满足条件时执行它的<code>内容语句</code>，这个语句可以是一个<code>语句块</code>，这样就可以实现有条件地执行多个语句了。</p><p><code>if</code> 语句还有 <code>else</code> 结构，用于不满足条件时执行，一种常见的用法是，利用语句的嵌套能力，把 <code>if</code> 和 <code>else</code> 连写成多分支条件判断：</p><pre class="hljs"><code><span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">10</span>) {
    <span class="hljs-comment">//...</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">20</span>) {
    <span class="hljs-comment">//...</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">30</span>) {
    <span class="hljs-comment">//...</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//...</span>
}

</code></pre><hr><h4 id="switch语句">switch语句 <a class="markdownIt-Anchor" href="#switch语句">#</a></h4><p>switch 语句继承自 <code>Java</code>，<code>Java</code> 中的 <code>switch</code> 语句继承自 <code>C</code> 和 <code>C++</code>，原本 <code>switch</code> 语句是跳转的变形，所以我们如果要用它来实现分支，必须要加上 <code>break</code>。</p><p>其实 <code>switch</code> 原本的设计是类似 <code>goto</code> 的思维。我们看一个例子：</p><pre class="hljs"><code><span class="hljs-keyword">switch</span>(num) {
<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    print(<span class="hljs-number">1</span>);
<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
    print <span class="hljs-number">2</span>;
<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
    print <span class="hljs-number">3</span>;
}

</code></pre><p>这段代码当 <code>num</code> 为 <code>1</code> 时输出 <code>1 2 3</code>，当 <code>num</code> 为 <code>2</code> 时输出 <code>2 3</code>，当 <code>num</code> 为 <code>3</code> 时输出 <code>3</code>。如果我们要把它变成分支型，则需要在每个 <code>case</code> 后加上 <code>break</code>。</p><pre class="hljs"><code><span class="hljs-keyword">switch</span>(num) {
<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    print <span class="hljs-number">1</span>;
    <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
    print <span class="hljs-number">2</span>;
    <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
    print <span class="hljs-number">3</span>;
    <span class="hljs-keyword">break</span>;
}

</code></pre><p>在 <code>C</code> 时代，<code>switch</code> 生成的汇编代码性能是略优于 <code>if else</code> 的，但是对 <code>JavaScript</code> 来说，则无本质区别。</p><hr><h4 id="for循环语句">for循环语句 <a class="markdownIt-Anchor" href="#for循环语句">#</a></h4><blockquote><p>for loop</p></blockquote><p>注意现在一般使用基础遍历循环中设置循环索引，一般使用<code>let</code>声明。</p><pre class="hljs"><code>
<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    <span class="hljs-built_in">console</span>.log(i);

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    <span class="hljs-built_in">console</span>.log(i);

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    <span class="hljs-built_in">console</span>.log(i);

</code></pre><hr><blockquote><p>for in loop</p></blockquote><p><code>for in</code> 循环枚举<code>对象</code>的<code>属性</code>，这里体现了属性的 <code>enumerable</code> 特征。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> o = { <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>}
<span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">"c"</span>, {<span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>:<span class="hljs-number">30</span>})

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p <span class="hljs-keyword">in</span> o)
    <span class="hljs-built_in">console</span>.log(p);

</code></pre><p>这段代码中，我们定义了一个对象 <code>o</code>，给它添加了不可枚举的属性 <code>c</code>，之后我们用 <code>for in</code> 循环枚举它的属性，我们会发现，输出时得到的只有 <code>a</code> 和 <code>b</code>。</p><p>如果定义 <code>c</code> 这个属性时，<code>enumerable</code> 为 <code>true</code>，则 <code>for in</code> 循环中也能枚举到它。</p><hr><blockquote><p>for of loop</p></blockquote><p>基于 iterator 机制，<code>for of</code>可以用于数组遍历。</p><pre class="hljs"><code><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
    <span class="hljs-built_in">console</span>.log(e);<span class="hljs-comment">// 1, 2, 3, 4, 5</span>

</code></pre><p>我们可以给任何一个对象添加 <code>iterator</code>，使它可以用于 <code>for of</code> 语句：</p><pre class="hljs"><code><span class="hljs-keyword">let</span> o = {  
    [<span class="hljs-built_in">Symbol</span>.iterator]:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">_value</span>: <span class="hljs-number">0</span>,
        next(){
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>._value == <span class="hljs-number">10</span>)
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>
                }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>._value++,
                <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>
            };
        }
    })
}
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> o)
    <span class="hljs-built_in">console</span>.log(e); <span class="hljs-comment">// 0,1,2,3,4,5,6,7,8,9</span>

</code></pre><p>上段代码展示了如何为一个对象添加 <code>iterator</code>。</p><p>在实际操作中，我们一般不会这样定义 <code>iterator</code>，可以使用 <code>generator function</code>。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
}
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> foo())
    <span class="hljs-built_in">console</span>.log(e);<span class="hljs-comment">// 0,1,2,3</span>

</code></pre><hr><blockquote><p>for await of loop</p></blockquote><p><code>JavaScript</code> 为异步生成器函数还配备了异步的 <code>for of</code>。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">duration</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
        setTimeout(resolve,duration);
    })
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);
        <span class="hljs-keyword">yield</span> i++;
    }

}
<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span>(<span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> foo())
    <span class="hljs-built_in">console</span>.log(e);

</code></pre><p>这段代码定义了一个异步生成器函数，异步生成器函数每隔一秒生成一个数字，这是一个无限的生成器。</p><p>接下来，我们使用 <code>for await of</code> 来访问这个异步生成器函数的结果，我们可以看到，这形成了一个每隔一秒打印一个数字的无限循环。</p><p>但是因为我们这个循环是异步的，并且有时间延迟，所以，这个无限循环的代码可以用于显示时钟等有意义的操作。</p><p>但是目前这个功能各大浏览器厂商，还没有做统一支持。</p><hr><h4 id="while循环语句">while循环语句 <a class="markdownIt-Anchor" href="#while循环语句">#</a></h4><p>注意，这里 <code>do while</code> 循环无论如何至少会执行一次。</p><blockquote><p>while loop</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span>
<span class="hljs-keyword">while</span>(a--) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"*"</span>);
}

</code></pre><hr><blockquote><p>do while loop</p></blockquote><pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">101</span>;
<span class="hljs-keyword">do</span> {
    <span class="hljs-built_in">console</span>.log(a);
} <span class="hljs-keyword">while</span>(a &lt; <span class="hljs-number">100</span>)


</code></pre><hr><h4 id="break语句">break语句 <a class="markdownIt-Anchor" href="#break语句">#</a></h4><p><code>break</code> 语句用于跳出循环语句或者 <code>switch</code> 语句，需要注意的是，支持带标签的用法。</p><p>带标签的 <code>break</code> 可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。</p><pre class="hljs"><code>outer:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    <span class="hljs-attr">inner</span>:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++)
        <span class="hljs-keyword">if</span>( i == <span class="hljs-number">50</span> &amp;&amp; j == <span class="hljs-number">50</span>)
            <span class="hljs-keyword">break</span> outer;

</code></pre><hr><h4 id="continue语句">continue语句 <a class="markdownIt-Anchor" href="#continue语句">#</a></h4><p><code>continue</code> 语句用于结束本次循环并继续循环，需要注意的是，支持带标签的用法。</p><p>带标签的 <code>continue</code> 可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。</p><pre class="hljs"><code>outer:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    <span class="hljs-attr">inner</span>:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++)
        <span class="hljs-keyword">if</span>( i &gt;= <span class="hljs-number">50</span> &amp;&amp; j == <span class="hljs-number">50</span>)
            <span class="hljs-keyword">continue</span> outer;

</code></pre><hr><h4 id="return语句">return语句 <a class="markdownIt-Anchor" href="#return语句">#</a></h4><p><code>return</code> 语句用于函数中，它终止函数的执行，并且指定函数的<code>返回值</code>。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">squre</span>(<span class="hljs-params">x</span>)</span>{
    <span class="hljs-keyword">return</span> x * x;
}

</code></pre><hr><h4 id="throw语句">throw语句 <a class="markdownIt-Anchor" href="#throw语句">#</a></h4><p>一般来说，<code>throw</code> 用于抛出异常，通常与<code>try</code> 语句组合使用，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用 <code>throw</code> 表达任何非异常逻辑。</p><pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"error"</span>);
} <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-built_in">console</span>.log(e);
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"finally"</span>);
}
</code></pre><hr><h4 id="try语句">try语句 <a class="markdownIt-Anchor" href="#try语句">#</a></h4><p>try 语句用于处理异常，通常与throw 语句组合使用。在大型应用中，异常机制非常重要。</p><pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"error"</span>);
} <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-built_in">console</span>.log(e);
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"finally"</span>);
}

</code></pre><p><code>try</code> 语句用于捕获异常，用 <code>throw</code> 抛出的异常，可以在 <code>try</code> 语句的结构中被处理掉：<code>try</code> 部分用于标识捕获异常的代码段，<code>catch</code> 部分则用于捕获异常后做一些处理，而 <code>finally</code> 则是用于执行后做一些必须执行的清理工作。</p><p><code>catch</code> 结构会创建一个局部的作用域，并且把一个变量写入其中，需要注意，在这个作用域，不能再声明变量 <code>e</code> 了，否则会出错。</p><p>在 <code>catch</code> 中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这样做，保证抛出的错误能被理解。</p><p><code>finally</code> 语句一般用于释放资源，它一定会被执行，我们在前面的课程中已经讨论过一些 <code>finally</code> 的特征，即使在 <code>try</code> 中出现了 <code>return</code>，<code>finally</code> 中的语句也一定要被执行。</p><hr><h3 id="debugger语句">debugger语句 <a class="markdownIt-Anchor" href="#debugger语句">#</a></h3><p><code>debugger</code> 语句的作用是：通知调试器在此断点。在没有调试器挂载时，它不产生任何效果。</p><pre class="hljs"><code><span class="hljs-keyword">if</span>(condition){
    <span class="hljs-keyword">debugger</span>;
    <span class="hljs-comment">// blabla</span>
}
</code></pre><hr><h3 id="with语句">with语句 <a class="markdownIt-Anchor" href="#with语句">#</a></h3><p><code>with</code> 语句是个非常巧妙的设计，把对象的属性在它内部的作用域内变成变量。</p><p>但它把 <code>JavaScript</code> 的变量引用关系变得不可分析，所以一般都认为这种语句都属于糟粕。</p><p>但是历史无法改写，现在已经无法去除 <code>with</code> 了。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> o = {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>}
<span class="hljs-keyword">with</span>(o){
    <span class="hljs-built_in">console</span>.log(a, b);
}

</code></pre><hr><h3 id="带标签语句">带标签语句 <a class="markdownIt-Anchor" href="#带标签语句">#</a></h3><p>实际上，任何 <code>JavaScript</code> 语句是可以加标签的，在语句前加冒号即可</p><pre class="hljs"><code>    firstStatement: <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;

</code></pre><p>大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与 <a href="http://www.ecma-international.org/ecma-262/#_ref_123" target="_blank" rel="noopener">完成记录</a> 类型中的 <code>target</code> 相配合，用于跳出多层循环。</p><pre class="hljs"><code>    outer: <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
      <span class="hljs-attr">inner</span>: <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">break</span> outer;
      }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"finished"</span>)

</code></pre><p><code>break/continue</code> 语句如果后跟了关键字，会产生带 target 的完成记录。一旦<a href="http://www.ecma-international.org/ecma-262/#_ref_123" target="_blank" rel="noopener">完成记录</a>带了 <code>target</code>，那么只有拥有对应 <code>label</code> 的循环语句会消费它。</p><hr><h2 id="声明型语句">声明型语句 <a class="markdownIt-Anchor" href="#声明型语句">#</a></h2><h3 id="var声明">var声明 <a class="markdownIt-Anchor" href="#var声明">#</a></h3><p><code>var</code> 声明语句是古典的 <code>JavaScript</code> 中声明变量的方式。而现在，在绝大多数情况下，<code>let</code> 和 <code>const</code> 都是更好的选择。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;
doSth(x, y);

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">10</span>; x++)
    doSth2(x);

</code></pre><p>如果仍然想要使用 <code>var</code>，我的个人建议是，把它当做一种<code>保障变量是局部</code>的逻辑，遵循以下三条规则：</p><ul><li>声明同时必定初始化；</li><li>尽可能在离使用的位置近处声明；</li><li>不要在意重复声明。</li></ul><hr><h3 id="let声明">let声明 <a class="markdownIt-Anchor" href="#let声明">#</a></h3><p>这里具体就不细讲了，需要看详细内容，请查看<a href="./let.html" target="_blank" rel="noopener">第二章</a>。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;

</code></pre><hr><h3 id="const声明">const声明 <a class="markdownIt-Anchor" href="#const声明">#</a></h3><p>这里具体就不细讲了，需要看详细内容，请查看<a href="./const.html" target="_blank" rel="noopener">第三章</a>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">console</span>.log(a);
}
<span class="hljs-built_in">console</span>.log(a);

</code></pre><hr><h3 id="class声明">Class声明 <a class="markdownIt-Anchor" href="#class声明">#</a></h3><p><code>class</code> 最基本的用法只需要 <code>class</code> 关键字、名称和一对大括号。</p><p>它的声明特征跟 <code>const</code> 和 <code>let</code> 类似，都是作用于<code>块级作用域</code>，预处理阶段则会屏蔽外部变量。</p><p>注意<code>Class</code>声明内部，默认开启了严格模式。</p><p><code>class</code> 内部，可以使用 <code>constructor</code> 关键字来定义构造函数。还能定义 <code>getter/setter</code> 和方法。</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>{
  <span class="hljs-keyword">constructor</span>(height, width) {
    <span class="hljs-keyword">this</span>.height = height;
    <span class="hljs-keyword">this</span>.width = width;
  }
  <span class="hljs-comment">// Getter</span>
  <span class="hljs-keyword">get</span> area() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calcArea();
  }
  <span class="hljs-comment">// Method</span>
  calcArea() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;
  }
}

</code></pre><hr><h3 id="函数声明">函数声明 <a class="markdownIt-Anchor" href="#函数声明">#</a></h3><blockquote><p>普通函数声明</p></blockquote><p>function 关键词，事件名，参数组，和成对的大括号。</p><pre class="hljs"><code>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{

}

<span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

}

</code></pre><hr><blockquote><p>async函数声明</p></blockquote><p><code>async</code> 函数是可以暂停执行，等待异步操作的函数，它的底层是 <code>Promise</code> 机制。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">3000</span>);
}

</code></pre><hr><blockquote><p>generator函数声明</p></blockquote><p>带 <code>*</code> 的函数是 <code>generator</code>，生成器函数可以理解为返回一个<code>序列</code>的<code>函数</code>，它的底层是 <code>iterator</code> 机制。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
}

</code></pre><hr><blockquote><p>async generator 函数声明</p></blockquote><p>异步生成器函数则是<code>Promise</code> 机制和<code>iterator</code> 机制的结合。</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">3000</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
}
</code></pre><hr><h2 id="语句的completion-record">语句的Completion Record <a class="markdownIt-Anchor" href="#语句的completion-record">#</a></h2><p>除了七种语言类型(<code>Undefined</code> <code>Null</code> <code>Boolean</code> <code>String</code> <code>Number</code> <code>Symbol</code> <code>Object</code>)，还有一些语言的实现者更关心的规范类型。</p><ul><li>List 和 Record： 用于描述函数传参过程。</li><li>Set：主要用于解释字符集等。</li><li>Completion Record：用于描述异常、跳出等语句执行过程。</li><li>Reference：用于描述对象属性访问、delete 等。</li><li>Property Descriptor：用于描述对象的属性。</li><li>Lexical Environment 和 Environment Record：用于描述变量和作用域。</li><li>Data Block：用于描述二进制数据。</li></ul><hr><h3 id="基础说明">基础说明 <a class="markdownIt-Anchor" href="#基础说明">#</a></h3><blockquote><p><a href="http://www.ecma-international.org/ecma-262/#_ref_123" target="_blank" rel="noopener">Completion Record by ECMA</a></p></blockquote><p>The Completion type is a Record used to explain the runtime propagation of values and control flow such as the behaviour of statements (break, continue, return and throw) that perform nonlocal transfers of control.</p><p>完成类型是一个记录，用于解释值和控制流的运行时传播，例如执行非本地控制传输的语句(<code>break</code>、<code>continue</code>、<code>return</code>和<code>throw</code>)的行为。</p><p>Values of the Completion type are Record values whose fields are defined as by Table 8. Such values are referred to as Completion Records.</p><p>补全类型的值是记录值，其字段定义如下图所示。这些值称为完成记录。</p><table><thead><tr><th style="text-align:left">Field Name</th><th style="text-align:left">Value</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">[[Type]]</td><td style="text-align:left">One of normal, break, continue, return, or throw</td><td style="text-align:left">The type of completion that occurred.</td></tr><tr><td style="text-align:left">[[Value]]</td><td style="text-align:left">any ECMAScript language value or empty</td><td style="text-align:left">The value that was produced.</td></tr><tr><td style="text-align:left">[[Target]]</td><td style="text-align:left">any ECMAScript string or empty</td><td style="text-align:left">The target label for directed control transfers.</td></tr></tbody></table><p>The term “abrupt completion” refers to any completion with a <code>[[Type]]</code> value other than normal.</p><p>“突然补全”一词是指除正常补全外，任何具有<code>[[类型]]</code>值的补全。</p><blockquote><p><a href="https://time.geekbang.org/column/article/83860" target="_blank" rel="noopener">Completion Record by Winter</a></p></blockquote><p><code>Completion Record</code> 表示一个语句执行完之后的结果，它有三个字段。</p><table><thead><tr><th style="text-align:left">Field Name</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">[[type]]</td><td style="text-align:left">表示完成的类型，有 break continue return throw 和 normal 几种类型；</td></tr><tr><td style="text-align:left">[[value]]</td><td style="text-align:left">表示语句的返回值，如果语句没有，则是 empty；</td></tr><tr><td style="text-align:left">[[target]]</td><td style="text-align:left">表示语句的目标，通常是一个 JavaScript 标签，如果语句没有，则是 empty。</td></tr></tbody></table><p><code>JavaScript</code> 正是依靠语句的 <code>Completion Record</code> 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。比如，Chrome 控制台显示的正是语句的 Completion Record 的 <code>[[value]]</code>。</p><hr><h3 id="原理分析">原理分析 <a class="markdownIt-Anchor" href="#原理分析">#</a></h3><p>接下来我们要来了解一下 <code>JavaScript</code> 使用 <code>Completion Record</code> 类型，控制语句执行的过程。</p><p>语句块本身并不复杂，我们需要注意的是语句块内部的语句的 <code>Completion Record</code> 的 <code>[[type]]</code> 如果不为 <code>normal</code>，会打断语句块后续的语句执行。</p><blockquote><p>return [[type]]</p></blockquote><p><code>return</code> 语句可能产生 <code>return</code> 或者 <code>throw</code> 类型的 <code>Completion Record</code>。</p><p>比如下面案例，一个内部为<code>普通语句</code>的语句块：</p><pre class="hljs"><code>{
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// normal, empty, empty</span>
  i ++; <span class="hljs-comment">// normal, 1, empty</span>
  <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//normal, undefined, empty</span>
} <span class="hljs-comment">// normal, undefined, empty</span>

</code></pre><p>在每一行的注释中，写出了语句的 <code>Completion Record</code>。</p><p>我们看到，在一个 <code>block</code> 中，如果每一个语句都是 <code>normal</code> 类型，那么它会顺次执行。接下来我们加入 <code>return</code> 试试看。</p><pre class="hljs"><code>{
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// normal, empty, empty</span>
  <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// return, 1, empty</span>
  i ++;
  <span class="hljs-built_in">console</span>.log(i)
} <span class="hljs-comment">// return, 1, empty</span>

</code></pre><p>但是假如我们在 <code>block</code> 中插入了一条 <code>return</code> 语句，产生了一个非 <code>normal</code> 记录，那么整个 <code>block</code> 会成为非 <code>normal</code>。</p><p>这个结构就保证了<code>非 normal</code> 的完成类型可以<code>穿透</code>复杂的语句嵌套结构，产生控制效果。</p><hr><blockquote><p>break continue throw [[type]]</p></blockquote><p>控制型语句带有 <code>if</code>、<code>switch</code> 关键字，它们会对不同类型的 <code>Completion Record</code> 产生反应。</p><p>控制类语句分成两部分，</p><ul><li>对其内部造成影响，如 <code>if</code>、<code>switch</code>、<code>while/for</code>、<code>try</code>。</li><li>另一类是对外部造成影响如 <code>break</code>、<code>continue</code>、<code>return</code>、<code>throw</code>。</li></ul><p>这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。</p><p>一般来说， <code>for/while</code> - <code>break/continue</code> 和 <code>try - throw</code> 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟 <code>break</code> 、<code>continue</code> 、<code>return</code> 、<code>throw</code> 四种类型与控制语句两两组合产生的效果。</p><table><thead><tr><th style="text-align:left">语句名</th><th style="text-align:left">break</th><th style="text-align:left">continue</th><th style="text-align:left">return</th><th style="text-align:left">throw</th></tr></thead><tbody><tr><td style="text-align:left">if</td><td style="text-align:left">穿透</td><td style="text-align:left">穿透</td><td style="text-align:left">穿透</td><td style="text-align:left">穿透</td></tr><tr><td style="text-align:left">switch</td><td style="text-align:left">消费</td><td style="text-align:left">穿透</td><td style="text-align:left">穿透</td><td style="text-align:left">穿透</td></tr><tr><td style="text-align:left">for/while</td><td style="text-align:left">消费</td><td style="text-align:left">消费</td><td style="text-align:left">穿透</td><td style="text-align:left">穿透</td></tr><tr><td style="text-align:left">function</td><td style="text-align:left">报错</td><td style="text-align:left">报错</td><td style="text-align:left">消费</td><td style="text-align:left">穿透</td></tr><tr><td style="text-align:left">try</td><td style="text-align:left">特殊处理</td><td style="text-align:left">特殊处理</td><td style="text-align:left">特殊处理</td><td style="text-align:left">消费</td></tr><tr><td style="text-align:left">catch</td><td style="text-align:left">特殊处理</td><td style="text-align:left">特殊处理</td><td style="text-align:left">特殊处理</td><td style="text-align:left">穿透</td></tr><tr><td style="text-align:left">finally</td><td style="text-align:left">特殊处理</td><td style="text-align:left">特殊处理</td><td style="text-align:left">特殊处理</td><td style="text-align:left">穿透</td></tr></tbody></table><p>因为 <code>finally</code> 中的内容必须保证执行，所以 <code>try/catch</code> 执行完毕，即使得到的结果是<code>非 normal</code> 型的完成记录，也必须要执行 <code>finally</code>。</p><p>而当 <code>finally</code> 执行也得到了<code>非 normal</code> 记录，则会使 <code>finally</code> 中的记录作为整个 <code>try</code> 结构的结果。</p><p>因为 <code>JavaScript</code> 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行， 树形结构的每一个节点执行后产生 <code>Completion Record</code>，根据语句的结构和 <code>Completion Record</code>，<code>JavaScript</code> 实现了各种<code>分支</code>和跳出<code>逻辑</code>。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters02/const.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters03/index.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item chapter-item-current"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters02/statement-details.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%99%AE%E9%80%9A%E5%9E%8B%E8%AF%AD%E5%8F%A5">普通型语句</a>\n<ul>\n<li><a href="#%E8%AF%AD%E5%8F%A5%E5%9D%97">语句块</a></li>\n<li><a href="#%E7%A9%BA%E8%AF%AD%E5%8F%A5">空语句</a></li>\n<li><a href="#%E6%8E%A7%E5%88%B6%E5%9E%8B%E8%AF%AD%E5%8F%A5">控制型语句</a></li>\n<li><a href="#debugger%E8%AF%AD%E5%8F%A5">debugger语句</a></li>\n<li><a href="#with%E8%AF%AD%E5%8F%A5">with语句</a></li>\n<li><a href="#%E5%B8%A6%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5">带标签语句</a></li>\n</ul>\n</li>\n<li><a href="#%E5%A3%B0%E6%98%8E%E5%9E%8B%E8%AF%AD%E5%8F%A5">声明型语句</a>\n<ul>\n<li><a href="#var%E5%A3%B0%E6%98%8E">var声明</a></li>\n<li><a href="#let%E5%A3%B0%E6%98%8E">let声明</a></li>\n<li><a href="#const%E5%A3%B0%E6%98%8E">const声明</a></li>\n<li><a href="#class%E5%A3%B0%E6%98%8E">Class声明</a></li>\n<li><a href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">函数声明</a></li>\n</ul>\n</li>\n<li><a href="#%E8%AF%AD%E5%8F%A5%E7%9A%84completion-record">语句的Completion Record</a>\n<ul>\n<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%B4%E6%98%8E">基础说明</a></li>\n<li><a href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">原理分析</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>
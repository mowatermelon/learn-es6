<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>严格模式 - learn es6</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">learn es6</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters07/index.html" class="breadcrumb-item">第七章 函数的扩展</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../chapters07/strict-mode.html" class="breadcrumb-item">严格模式</a></div><h1 class="article-title">严格模式</h1><div class="article"><h2 id="基本说明"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">基本说明</a> <a class="markdownIt-Anchor" href="#基本说明">#</a></h2><p><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">ECMAScript 5</a>的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>是采用具有限制性<code>JavaScript</code>变体的一种方式，从而使代码显示地 脱离<code>马虎模式</code>/<code>稀松模式</code>/<code>懒散模式</code>（<code>sloppy</code>）模式。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>不仅仅是一个子集：它的产生是为了形成与正常代码不同的语义。<br>不支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>与支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>的浏览器在执行<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>代码时会采用不同行为。</p><p>所以在没有对<code>运行环境</code>展开特性测试来验证对于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>相关方面支持的情况下，就算采用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>也不一定会取得预期效果。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>代码和非<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>代码可以共存，因此项目脚本可以渐进式地采用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>对正常的 <code>JavaScript</code>语义做了一些更改。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>通过抛出错误来消除了一些原有<code>静默错误</code>。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>修复了一些导致 <code>JavaScript引擎</code>难以执行优化的缺陷：有时候，相同的代码，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>可以比非<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>下运行得更快。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>禁用了在<code>ECMAScript</code>的未来版本中可能会定义的一些语法。</li></ul><p><code>主流浏览器</code>现在实现了<code>严格模式</code>。</p><p>但是不要盲目的依赖它，因为市场上仍然有大量的<code>浏览器</code>版本只部分支持<code>严格模式</code>或者根本就不支持（比如<code>IE10</code>之前的版本）。</p><p><code>严格模式</code>改变了<code>语义</code>。依赖这些改变可能会导致没有实现<code>严格模式</code>的浏览器中出现<code>问题</code>或者<code>错误</code>。</p><p>谨慎地使用<code>严格模式</code>，通过检测相关代码的功能保证<code>严格模式</code>不出问题。</p><p>最后，记得在<code>支持</code>或者<code>不支持</code>严格模式的<code>浏览器</code>中测试你的<code>代码</code>。</p><p>如果你只在不支持<code>严格模式</code>的浏览器中<code>测试</code>，那么在<code>支持</code>的浏览器中就很有可能出问题，反之亦然。</p><hr><h2 id="开启严格模式"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode" target="_blank" rel="noopener">开启严格模式</a> <a class="markdownIt-Anchor" href="#开启严格模式">#</a></h2><p><code>严格模式</code>可以应用到整个<code>脚本</code>或个别<code>函数</code>中。</p><p>不要在封闭大括弧 <code>{}</code> 内这样做，在这样的上下文中这么做是没有效果的。在 <code>eval</code> 、<code>Function</code> 、<code>内联事件</code>处理属性、 <code>WindowTimers.setTimeout()</code> 方法中传入的<code>脚本字符串</code>，其行为类似于开启了<code>严格模式</code>的一个单独<code>脚本</code>，它们会如预期一样工作。</p><hr><h3 id="脚本开启">脚本开启 <a class="markdownIt-Anchor" href="#脚本开启">#</a></h3><p>为整个<code>脚本文件</code>开启<code>严格模式</code>，需要在所有语句之前放一个特定语句 <code>'use strict'</code>; （或 <code>'use strict';</code>）</p><pre class="hljs"><code><span class="hljs-comment">// 整个脚本都开启严格模式的语法</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">const</span> v = <span class="hljs-string">"Hi!  I'm a strict mode script!"</span>;
</code></pre><p>这种语法存在陷阱，<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=627531" target="_blank" rel="noopener">Amazon</a>被它<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=579119" target="_blank" rel="noopener">坑倒</a>了：不能<code>盲目</code>的合并<code>冲突代码</code>。</p><p>试想合并一个<code>严格模式</code>的<code>脚本</code>和一个<code>非严格模式</code>的<code>脚本</code>：合并后的<code>脚本代码</code>看起来是<code>严格模式</code>。</p><p>反之亦然：<code>非严格</code>合并<code>严格</code>看起来是<code>非严格</code>的。</p><p>合并均为<code>严格模式</code>的<code>脚本</code>或均为<code>非严格模式</code>的都没问题，只有在合并<code>严格模式</code>与<code>非严格模式</code>有可能有问题。</p><p>建议按一个个<code>函数</code>去开启<code>严格模式</code>（至少在学习的过渡期要这样做）.</p><p>您也可以将整个<code>脚本</code>的内容用一个<code>函数</code>包括起来，然后在这个<code>外部函数</code>中使用<code>严格模式</code>。这样做就可以<code>消除合并</code>的问题，但是这就意味着您必须要在<code>函数</code>作用域外声明一个<code>全局变量</code>。</p><hr><h3 id="函数开启">函数开启 <a class="markdownIt-Anchor" href="#函数开启">#</a></h3><p>同样的，要给某个函数开启<code>严格模式</code>，得把 <code>&quot;use strict&quot;;</code> (或 <code>'use strict';</code> )声明<code>一字不漏</code>地放在<code>函数体</code>所有<code>语句</code>之前。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> strict = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> {
    <span class="hljs-comment">// 函数级别严格模式语法</span>
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">const</span> nested = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"And so am I!"</span>; }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hi!  I'm a strict mode function!  "</span> + nested();
  }
  <span class="hljs-keyword">const</span> notStrict = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"I'm not strict."</span>; }
})();
</code></pre><hr><h2 id="作用说明">作用说明 <a class="markdownIt-Anchor" href="#作用说明">#</a></h2><p><code>严格模式</code>同时<code>改变</code>了<code>语法</code>及运行时<code>行为</code>。</p><p><code>变化</code>通常分为这几类</p><ul><li>将问题直接转化为<code>错误</code>（如<code>语法错误</code>或<code>运行时错误</code>）</li><li>简化了如何为给定<code>名称</code>的特定变量计算</li><li>简化了 <code>eval</code> 以及 <code>arguments</code>, 将写安全<code>JavaScript</code>的<code>步骤</code>变得更<code>简单</code>，以及改变了预测未来<code>ECMAScript</code>行为的方式。</li></ul><hr><h3 id="将过失错误转成异常">将过失错误转成异常 <a class="markdownIt-Anchor" href="#将过失错误转成异常">#</a></h3><p>在严格模式下, 某些先前被接受的<code>过失错误</code>将会被认为是<code>异常</code>. <code>JavaScript</code>被设计为能使新人开发者更易于上手, 所以有时候会给本来错误操作赋予新的不报错误的语义(<code>non-error semantics</code>).</p><p>有时候这可以解决当前的问题, 但有时候却会给以后留下更大的问题. <code>严格模式</code>则把这些<code>失误</code>当成<code>错误</code>, 以便可以发现并立即将其改正.</p><hr><h3 id="简化变量的使用">简化变量的使用 <a class="markdownIt-Anchor" href="#简化变量的使用">#</a></h3><blockquote><p>禁用<code>with</code></p></blockquote><p><code>严格模式</code>禁用 <code>with</code>.</p><p><code>with</code>所引起的问题是块内的任何名称可以<code>映射</code>(<code>map</code>)到<code>with</code>传进来的对象的<code>属性</code>, 也可以<code>映射</code>到<code>包围</code>这个块的<code>作用域</code>内的<code>变量</code>(甚至是<code>全局变量</code>), 这一切都是在运行时决定的: 在代码运行之前是无法得知的.</p><p><code>严格模式</code>下, 使用 <code>with</code> 会引起<code>语法错误</code>, 所以就不会存在 <code>with</code> 块内的<code>变量</code>在运行是才决定<code>引用</code>到哪里的情况了:</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-keyword">const</span> x = <span class="hljs-number">17</span>;
  <span class="hljs-keyword">with</span> (obj) <span class="hljs-comment">// Uncaught SyntaxError: Strict mode code may not include a with statement</span>
  {
    <span class="hljs-comment">// 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？</span>
    <span class="hljs-comment">// 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。</span>
    x;
  }
})()
</code></pre><p>一种取代 <code>with</code>的简单方法是，将<code>目标对象</code>赋给一个<code>短命名变量</code>，然后访问这个<code>变量</code>上的<code>相应属性</code>.</p><hr><blockquote><p>引入新变量</p></blockquote><p>严格模式下的 <code>eval</code> 不再为上层范围(<code>surrounding scope</code>,注:包围<code>eval</code> 代码块的范围)引入<code>新变量</code>.</p><p>在<code>正常模式</code>下, 代码 <code>eval(&quot;var x;&quot;)</code> 会给上层函数(<code>surrounding function</code>)或者全局引入一个新的变量 <code>x</code> .</p><p>这意味着, 一般情况下, 在一个包含 <code>eval</code> 调用的<code>函数</code>内所有没有引用到<code>参数</code>或者<code>局部变量</code>的<code>名称</code>都必须在运行时才能被<code>映射</code>到<code>特定</code>的<code>定义</code> (因为 <code>eval</code> 可能引入的<code>新变量</code>会覆盖它的<code>外层变量</code>).</p><p>在严格模式下 <code>eval</code> 仅仅为被运行的代码<code>创建变量</code>, 所以 <code>eval</code> 不会使得名称<code>映射</code>到<code>外部变量</code>或者其他<code>局部变量</code></p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> {assert, log} = <span class="hljs-built_in">console</span>;
  <span class="hljs-keyword">const</span> x = <span class="hljs-number">17</span>;
  <span class="hljs-keyword">const</span> evalX = <span class="hljs-built_in">eval</span>(<span class="hljs-string">"'use strict'; const x = 42; x"</span>);
  log(assert(x !== <span class="hljs-number">17</span>,<span class="hljs-string">'yes it is 17'</span>));<span class="hljs-comment">// Assertion failed: yes it is 17</span>
  log(assert(evalX !== <span class="hljs-number">42</span>,<span class="hljs-string">'yes it is 42'</span>));<span class="hljs-comment">// Assertion failed: yes it is 42</span>
})()
</code></pre><p>相应的, 如果函数 <code>eval</code> 被在<code>严格模式</code>下的<code>eval(...)</code>以表达式的形式调用时, 其代码会被当做<code>严格模式</code>下的代码执行.</p><p>当然也可以在代码中显式开启<code>严格模式</code>, 但这样做并不是必须的.</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { log } = <span class="hljs-built_in">console</span>;
  <span class="hljs-keyword">const</span> strict1 = <span class="hljs-function">(<span class="hljs-params">str</span>)=&gt;</span>{
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str); <span class="hljs-comment">// str中的代码在严格模式下运行</span>
  }
  <span class="hljs-keyword">const</span> strict2 = <span class="hljs-function">(<span class="hljs-params">f, str</span>)=&gt;</span>{
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">return</span> f(str); <span class="hljs-comment">// 没有直接调用eval(...): 当且仅当str中的代码开启了严格模式时</span>
    <span class="hljs-comment">// 才会在严格模式下运行</span>
  }
  <span class="hljs-keyword">const</span> nonStrict = <span class="hljs-function">(<span class="hljs-params">str</span>)=&gt;</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str); <span class="hljs-comment">// 当且仅当str中的代码开启了"use strict"，str中的代码才会在严格模式下运行</span>
  }

  log(strict1(<span class="hljs-string">"'Strict mode code!'"</span>)); <span class="hljs-comment">// Strict mode code!</span>
  log(strict1(<span class="hljs-string">"'use strict'; 'Strict mode code!'"</span>)); <span class="hljs-comment">// Strict mode code!</span>
  log(strict2(<span class="hljs-built_in">eval</span>, <span class="hljs-string">"'Non-strict code.'"</span>)); <span class="hljs-comment">// Non-strict code.</span>
  log(strict2(<span class="hljs-built_in">eval</span>, <span class="hljs-string">"'use strict'; 'Strict mode code!'"</span>)); <span class="hljs-comment">// Strict mode code!</span>
  log(nonStrict(<span class="hljs-string">"'Non-strict code.'"</span>)); <span class="hljs-comment">// Non-strict code.</span>
  log(nonStrict(<span class="hljs-string">"'use strict'; 'Strict mode code!'"</span>)); <span class="hljs-comment">// Strict mode code!</span>
})()
</code></pre><p>因此，在 <code>eval</code> 执行的严格模式代码下，变量的行为与严格模式下非 <code>eval</code> 执行的代码中的变量相同。</p><hr><blockquote><p>严格模式禁止删除声明变量</p></blockquote><p><code>delete name</code> 在<code>严格模式</code>下会引起<code>语法错误</code></p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;

<span class="hljs-comment">//   const x;// Uncaught SyntaxError: Missing initializer in const declaration</span>
  <span class="hljs-keyword">let</span> x;
  <span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span>

 <span class="hljs-comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span>
  <span class="hljs-built_in">eval</span>(<span class="hljs-string">"let y; delete y;"</span>);
})()
</code></pre><hr><h3 id="严格控制eval和arguments">严格控制<code>eval</code>和<code>arguments</code> <a class="markdownIt-Anchor" href="#严格控制eval和arguments">#</a></h3><p><code>严格模式</code>让<code>arguments</code>和<code>eval</code>少了一些奇怪的行为。</p><p>两者在通常的代码中都包含了很多奇怪的行为： <code>eval</code>会添加<code>删除绑定</code>，改变绑定好的值，还会通过用它<code>索引</code>过的<code>属性</code>给<code>形参</code>取别名的方式修改<code>形参</code>.</p><p>虽然在未来的<code>ECMAScript</code>版本解决这个问题之前，是不会有<code>补丁</code>来完全修复这个问题，但严格模式下将<a href="#eval%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8C%BA%E5%88%AB">eval</a> 和<code>arguments</code>作为<code>关键字</code>对于此问题的解决是很有帮助的。</p><blockquote><p>名称 <code>eval</code> 和 <code>arguments</code> 不能通过程序语法被绑定(<code>be bound</code>)或<code>赋值</code>. 以下的所有尝试将引起语法错误:</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-built_in">eval</span> = <span class="hljs-number">17</span>; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-built_in">arguments</span>++; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  ++<span class="hljs-built_in">eval</span>; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-keyword">const</span> obj = { <span class="hljs-keyword">set</span> p(arguments) { } }; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">eval</span>; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-keyword">try</span> { } <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">arguments</span>) { } <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params">eval</span>) </span>{ } <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arguments</span>(<span class="hljs-params"></span>) </span>{ } <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eval</span>(<span class="hljs-params"></span>) </span>{ }; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
  <span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"arguments"</span>, <span class="hljs-string">"'use strict'; return 17;"</span>); <span class="hljs-comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span>
})()
</code></pre><hr><blockquote><p><a href="#arguments%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%96%B0">arguments对象属性更新</a></p></blockquote><p><code>严格模式</code>下，参数的值不会随 <code>arguments</code> 对象的值的改变而变化。</p><p>在<code>正常模式</code>下，对于第一个参数是 <code>arg</code> 的函数，对 <code>arg</code> 赋值时会同时赋值给 <code>arguments[0]</code>，反之亦然（除非没有参数，或者 <code>arguments[0]</code> 被删除）。严格模式下，函数的 <code>arguments</code> 对象会保存函数被调用时的<code>原始参数</code>。</p><p><code>arguments[i]</code> 的值不会随与之相应的参数的值的<code>改变</code>而<code>变化</code>，<code>同名参数</code>的值也不会随与之相应的 <code>arguments[i]</code> 的值的<code>改变</code>而<code>变化</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> {assert} = <span class="hljs-built_in">console</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>)</span>{
    <span class="hljs-string">'use strict'</span>;
    a = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];
  }
  <span class="hljs-keyword">const</span> pair = f(<span class="hljs-number">17</span>);
  assert(pair[<span class="hljs-number">0</span>] === <span class="hljs-number">42</span>);
  assert(pair[<span class="hljs-number">1</span>] === <span class="hljs-number">17</span>);
})()
</code></pre><hr><blockquote><p>arguments对象和函数属性</p></blockquote><p>在<code>严格模式</code>下,访问<code>arguments.callee</code>, <code>arguments.caller</code>, <code>anyFunction.caller</code>以及<code>anyFunction.arguments</code>都会抛出<code>异常</code>.</p><hr><blockquote><p>arguments.callee</p></blockquote><p><code>正常模式</code>下，<code>arguments.callee</code> 指向当前正在执行的函数。这个作用很小，唯一合法的使用应该是给<code>匿名函数</code>声明并且重用之。</p><p>此外，<code>arguments.callee</code> 十分不利于<code>优化</code>，例如<code>内联函数</code>，因为 <code>arguments.callee</code> 会依赖对非<code>内联函数</code>的引用。</p><p>在<code>严格模式</code>下，<code>arguments.callee</code> 是一个<code>不可删除属性</code>，而且<code>赋值</code>和<code>读取</code>时都会抛出<code>异常</code>。</p><pre class="hljs"><code><span class="hljs-comment">// example taken from vanillajs: http://vanilla-js.com/</span>
<span class="hljs-keyword">const</span> s = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'thing'</span>).style;
s.opacity = <span class="hljs-number">1</span>;
<span class="hljs-function">(<span class="hljs-params">(</span>)=&gt;</span>{
  <span class="hljs-keyword">if</span>((s.opacity-=<span class="hljs-number">.1</span>) &lt; <span class="hljs-number">0</span>){
    s.display=<span class="hljs-string">"none"</span>;
  }
  <span class="hljs-keyword">else</span>{
    setTimeout(<span class="hljs-built_in">arguments</span>.callee, <span class="hljs-number">40</span>);
  }
})();
</code></pre><p>可以重新写成:</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-keyword">const</span> s = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'thing'</span>).style;
  s.opacity = <span class="hljs-number">1</span>;
  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fadeOut</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">// name the function</span>
    <span class="hljs-keyword">if</span>((s.opacity-=<span class="hljs-number">.1</span>) &lt; <span class="hljs-number">0</span>){
      s.display = <span class="hljs-string">"none"</span>;
    }<span class="hljs-keyword">else</span>{
      setTimeout(fadeOut, <span class="hljs-number">40</span>); <span class="hljs-comment">// use the name of the function</span>
    }
  })();
})();
</code></pre><hr><blockquote><p>arguments.caller</p></blockquote><p>在一些旧时的<code>ECMAScript</code>实现中<code>arguments.caller</code>曾经是一个对象，里面<code>存储</code>的属性指向那个函数的<code>变量</code>。</p><p>这是一个<code>安全隐患</code>，因为它通过函数抽象打破了本来被<code>隐藏</code>起来的<code>保留值</code>；它同时也是引起大量<code>优化</code>工作的原因。</p><p>出于这些原因，现在的<code>浏览器</code>没有实现它。但是因为它这种历史遗留的功能，<code>arguments.caller</code>在严格模式下同样是一个不可被<code>删除</code>的<code>属性</code>，在<code>赋值</code>或者<code>取值</code>时会<code>报错</code></p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">a, b</span>)
  </span>{
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">var</span> v = <span class="hljs-number">12</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.caller; <span class="hljs-comment">// 抛出类型错误</span>
  }
  fun(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 不会暴露v（或者a，或者b）</span>
})();
</code></pre><hr><blockquote><p>anyFunction.caller</p></blockquote><p>在<code>严格模式</code>中再也不能通过广泛实现的<code>ECMAScript</code>扩展<code>游走于</code>JavaScript的栈中。</p><p>在普通模式下用这些扩展的话，当一个叫<code>fun</code>的函数正在被调用的时候，<code>fun.caller</code>是最后一个调用<code>fun</code>的函数，而且<code>fun.arguments</code>包含调用<code>fun</code>时用的形参。</p><p>这两个扩展接口对于<code>安全</code>JavaScript而言都是有问题的，因为他们允许<code>安全的</code>代码访问<code>专有</code>函数和他们的（通常是没有经过保护的）形参。</p><p>如果<code>fun</code>在严格模式下，那么<code>fun.caller</code>和<code>fun.arguments</code>都是不可删除的<code>属性</code>而且在<code>存值</code>、<code>取值</code>时都会报错</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restricted</span>(<span class="hljs-params"></span>)
  </span>{
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-comment">// Script snippet #6:5 Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them</span>
    restricted.caller;    <span class="hljs-comment">// 抛出类型错误 </span>
    restricted.arguments; <span class="hljs-comment">// 抛出类型错误</span>
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">privilegedInvoker</span>(<span class="hljs-params"></span>)
  </span>{
    <span class="hljs-keyword">return</span> restricted();
  }
  privilegedInvoker();
})();
</code></pre><hr><h3 id="安全的javascript">&quot;安全&quot;的JavaScript <a class="markdownIt-Anchor" href="#安全的javascript">#</a></h3><p><code>严格模式</code>下更容易写出<code>安全</code>的<code>JavaScript</code>。</p><p>现在有些网站提供了方式给用户编写能够被网站其他用户执行的<code>JavaScript</code>代码。</p><p>在浏览器环境下，<code>JavaScript</code>能够获取用户的<code>隐私信息</code>，因此这类<code>Javascript</code>必须在运行前部分被转换成需要申请访问<code>禁用功能</code>的<code>权限</code>。</p><p>没有很多的<code>执行</code>时检查的情况，<code>Javascript</code>的<code>灵活性</code>让它无法有效率地做这件事。</p><p>一些语言中的<code>函数</code>普遍出现，以至于执行时检查他们会引起严重的<code>性能损耗</code>。</p><p>做一些在<code>严格模式</code>下发生的小改动，要求用户提交的<code>JavaScript</code>开启<code>严格模式</code>并且用特定的方式调用，就会大大减少在执行时进行检查的<code>必要</code>。</p><p>在<code>严格模式</code>下通过<code>this</code>传递给一个<code>函数</code>的值不会被<code>强制</code>转换为一个<code>对象</code>。</p><p>对一个普通的<code>函数</code>来说，<code>this</code>总会是一个对象：不管调用时<code>this</code>它本来就是一个<code>对象</code>；还是用<code>布尔值</code>，<code>字符串</code>或者<code>数字</code>调用<code>函数</code>时<code>函数</code>里面被封装成对象的<code>this</code>；还是使用<code>undefined</code>或者<code>null</code>调用函数式<code>this</code>代表的全局对象（使用<code>call</code>, <code>apply</code>或者<code>bind</code>方法来指定一个确定的<code>this</code>）。</p><p>这种<code>自动转化</code>为对象的过程不仅是一种性能上的<code>损耗</code>，同时在<code>浏览器</code>中暴露出<code>全局对象</code>也会成为<code>安全隐患</code>，因为<code>全局对象</code>提供了访问那些所谓安全的<code>JavaScript</code>环境必须限制的功能的途径。</p><p>所以对于一个开启<code>严格模式</code>的函数，指定的<code>this</code>不再被封装为<code>对象</code>，而且如果<a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84this">没有指定<code>this</code>的话它值是<code>undefined</code></a>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { assert, log } = <span class="hljs-built_in">console</span>;
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
  log(fun());<span class="hljs-comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span>
  assert(fun() === <span class="hljs-literal">undefined</span>, <span class="hljs-string">'it is not undefined'</span>);<span class="hljs-comment">// Assertion failed: it is not undefined</span>
  log(fun.call(<span class="hljs-number">2</span>));<span class="hljs-comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span>
  assert(fun.call(<span class="hljs-number">2</span>) === <span class="hljs-number">2</span>, <span class="hljs-string">'it is not 2'</span>);<span class="hljs-comment">// Assertion failed: it is not 2</span>
  log(fun.apply(<span class="hljs-literal">null</span>));<span class="hljs-comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span>
  assert(fun.apply(<span class="hljs-literal">null</span>) === <span class="hljs-literal">null</span>, <span class="hljs-string">'it is not null'</span>);<span class="hljs-comment">// Assertion failed: it is not null</span>
  log(fun.call(<span class="hljs-literal">undefined</span>));<span class="hljs-comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span>
  assert(fun.call(<span class="hljs-literal">undefined</span>) === <span class="hljs-literal">undefined</span>);<span class="hljs-comment">// Assertion failed: it is not undefined</span>
  log(fun.bind(<span class="hljs-literal">true</span>));<span class="hljs-comment">// ƒ fun() { return this; }</span>
  assert(fun.bind(<span class="hljs-literal">true</span>)() === <span class="hljs-literal">true</span>, <span class="hljs-string">'it is not true'</span>);<span class="hljs-comment">// Assertion failed: it is not true</span>
})();
</code></pre><hr><h3 id="为之后规范铺路">为之后规范铺路 <a class="markdownIt-Anchor" href="#为之后规范铺路">#</a></h3><p>为未来的<code>ECMAScript</code>版本铺平道路</p><p>未来版本的<code>ECMAScript</code>很有可能会引入<code>新语法</code>，<code>ECMAScript5</code>中的<code>严格模式</code>就提早设置了一些限制来减轻之后版本改变产生的影响。如果提早使用了<code>严格模式</code>中的<code>保护机制</code>，那么做出改变就会变得更容易。</p><blockquote><p>新增保留关键字</p></blockquote><p>在<code>严格模式</code>中一部分字符变成了<code>保留</code>的<code>关键字</code>。</p><p>这些字符包括<code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>和<code>yield</code>。</p><p>在<code>严格模式</code>下，你不能再用这些名字作为<code>变量名</code>或者<code>形参名</code>。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">package</span>(<span class="hljs-params">protected</span>)</span>{ <span class="hljs-comment">// !!!</span>
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">var</span> implements; <span class="hljs-comment">// !!!</span>

    interface: <span class="hljs-comment">// !!!</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
      <span class="hljs-keyword">break</span> interface; <span class="hljs-comment">// !!!</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">private</span>(<span class="hljs-params"></span>) </span>{ } <span class="hljs-comment">// !!!</span>
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">static</span>) </span>{ <span class="hljs-string">'use strict'</span>; } <span class="hljs-comment">// !!!</span>
})();
</code></pre><p>两个针对<code>Mozilla</code>开发的警告：第一，如果你的JavaScript版本在1.7及以上（你的<code>chrome</code>代码或者你正确使用了<code>&lt;script type=&quot;&quot;&gt;</code>）并且开启了<code>严格模式</code>的话，因为<code>let</code>和<code>yield</code>是最先引入的关键字，所以它们会起作用。</p><p>但是网络上用<code>&lt;script src=&quot;&quot;&gt;</code>或者<code>&lt;script&gt;...&lt;/script&gt;</code>加载的代码，<code>let</code>或者<code>yield</code>都不会作为关键字起作用；</p><p>第二，尽管<code>ES5</code>无条件的保留了<code>class</code>, <code>enum</code>, <code>export</code>, <code>extends</code>, <code>import</code>和<code>super</code>关键字，在<code>Firefox 5</code>之前，<code>Mozilla</code>仅仅在<code>严格模式</code>中保留了它们。</p><hr><blockquote><p>禁止内部函数声明</p></blockquote><p><code>严格模式</code>禁止了不在<code>脚本</code>或者<code>函数</code>层面上的<code>函数声明</code>。</p><p>在<code>浏览器</code>的<code>普通代码</code>中，在<code>所有地方</code>的函数声明都是合法的。</p><p>这并不在<code>ES5</code>规范中（甚至是<code>ES3</code>）！这是一种针对不同<code>浏览器</code>中不同语义的一种<code>延伸</code>。</p><p>未来的<code>ECMAScript</code>版本很有希望制定一个新的，针对不在<code>脚本</code>或者<code>函数</code>层面进行<code>函数</code>声明的语法。</p><p>在<code>严格模式</code>下禁止这样的<code>函数</code>声明对于将来<code>ECMAScript</code>版本的推出扫清了障碍：</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>){
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ } <span class="hljs-comment">// !!! 语法错误</span>
    f();
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++){
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>{ } <span class="hljs-comment">// !!! 语法错误</span>
    f2();
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 合法</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eit</span>(<span class="hljs-params"></span>) </span>{ } <span class="hljs-comment">// 同样合法</span>
  }
})();
</code></pre><p>这种禁止放到<code>严格模式</code>中并不是很合适，因为这样的<code>函数声明</code>方式从<code>ES5</code>中延伸出来的。但这是<code>ECMAScript</code>委员会推荐的做法，<code>Mozilla浏览器</code>实现了这一点，但是在<code>chrome</code>中没有实现。</p><hr><h2 id="错误说明">错误说明 <a class="markdownIt-Anchor" href="#错误说明">#</a></h2><h3 id="语法错误"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="noopener">语法错误</a> <a class="markdownIt-Anchor" href="#语法错误">#</a></h3><p>如果代码中使用<code>'use strict'</code>开启了<code>严格模式</code>,则下面的情况都会在<code>脚本</code>运行之前抛出<code>SyntaxError</code>异常:</p><ul><li>八进制语法:<code>const n = 023</code>和<code>const s = &quot;\047&quot;</code>。</li><li><code>with</code>语句。</li><li>使用<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/delete" target="_blank" rel="noopener">delete</a>删除一个<code>变量名</code>(而不是<code>属性名</code>):<code>delete myVariable</code>。</li><li>使用<code>eval</code>或<code>arguments</code>作为<code>变量名</code>或<code>函数名</code>。</li><li>使用<code>未来保留字</code>(也许会在<code>ECMAScript 6</code>中使用):<code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>,和<code>yield</code>作为<code>变量名</code>或<code>函数名</code>。</li><li>在<code>语句块</code>中使用<code>函数声明</code>:<code>if(a&lt;b){ function f(){} }</code>。</li><li>其他错误<ul><li><code>对象字面量</code>中使用两个相同的<code>属性名</code>:<code>{a: 1, b: 3, a: 7}</code>。</li><li><code>函数形参</code>中使用两个相同的<code>参数名</code>:<code>function f(a, b, b){}</code>。</li></ul></li></ul><p>这些<code>错误</code>是有利的，因为可以揭示<code>简陋</code>的<code>错误</code>和坏的<code>实践</code>，这些<code>错误</code>会在代码运行前被<code>抛出</code></p><hr><blockquote><p>严格模式下无法再意外创建全局变量</p></blockquote><p>在普通的<code>JavaScript</code>里面给一个错误命名的<code>变量名</code>赋值会使<code>全局对象</code>新增一个属性并继续<code>工作</code>（尽管将来可能会失败：在现代的<code>JavaScript</code>中有可能）。</p><p><code>严格模式</code>中意外创建<code>全局变量</code>被抛出错误替代：</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  mistypedVaraible = <span class="hljs-number">17</span>;
  <span class="hljs-comment">// 这一行代码就会抛出 ReferenceError</span>
  <span class="hljs-comment">// Uncaught ReferenceError: mistypedVaraible is not defined</span>
})()
</code></pre><hr><blockquote><p>重名属性</p></blockquote><p>在<code>Gecko</code>版本<code>34</code>之前，<code>严格模式</code>要求一个对象内的所有<code>属性名</code>在对象内必须唯一。<br><code>正常模式</code>下<code>重名属性</code>是允许的, <code>重名参数</code>名会掩盖之前的<code>重名参数</code>，最后一个<code>重名</code>的<code>属性</code>决定其<code>属性值</code>。</p><p>之前的参数仍然可以通过 <code>arguments[i]</code> 来访问, 还不是完全无法访问.</p><p>因为只有最后一个<code>属性</code>起作用，当代码要去改变<code>属性值</code>而不是修改最后一个<code>重名属性</code>的时候，复制这个对象就产生一连串的<code>bug</code>。</p><p>然而, 这种隐藏<code>毫无意义</code>而且可能是<code>意料之外</code>的 (比如它可能本来是打错了), 所以在<code>严格模式</code>下<code>重名参数</code>被认为是<code>语法错误</code>。</p><p><code>严格模式</code>中意外创建<code>全局变量</code>被抛出错误替代：</p><pre class="hljs"><code><span class="hljs-meta">'use strict'</span>;
<span class="hljs-comment">// 假如有一个全局变量叫做mistypedVariable</span>
mistypedVaraible = <span class="hljs-number">17</span>; <span class="hljs-comment">// 因为变量名拼写错误</span>
<span class="hljs-comment">// 这一行代码就会抛出 ReferenceError</span>
<span class="hljs-comment">// Uncaught ReferenceError: mistypedVaraible is not defined</span>
</code></pre><hr><h3 id="运行时错误"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" target="_blank" rel="noopener">运行时错误</a> <a class="markdownIt-Anchor" href="#运行时错误">#</a></h3><p><code>JavaScript</code>曾经会在一些<code>上下文</code>的某些情况中<code>静默</code>的失败，<code>严格模式</code>会在这些情况下抛出错误。</p><p>如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。</p><p>再说一次，<code>严格模式</code>是可以设置在<code>代码粒度</code>下的。</p><hr><blockquote><p>未声明的变量赋值</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">const</span> a = <span class="hljs-number">12</span>;
    b = a + x*<span class="hljs-number">35</span>; <span class="hljs-comment">// Uncaught ReferenceError: b is not defined</span>
  }
  f();
})()
</code></pre><p><code>改变</code>一个<code>全局对象</code>的值可能会造成<code>不可预期</code>的后果。</p><p>如果你真的想设置一个<code>全局对象</code>的值，把他作为一个<code>参数</code>并且<code>明确</code>的把它作为一个<code>属性</code>：</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> global = <span class="hljs-keyword">this</span>;
  <span class="hljs-comment">// in the top-level context,</span>
  <span class="hljs-comment">// "this" always refers the global object</span>
  <span class="hljs-keyword">const</span> f = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">const</span> a = <span class="hljs-number">12</span>;
    global.b = a + x * <span class="hljs-number">35</span>;
  }
  f();
})()
</code></pre><hr><blockquote><p>尝试删除一个不可配置的属性</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-keyword">delete</span> <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// Uncaught TypeError: Cannot delete property 'prototype' of function Object() { [native code] }</span>
})()
</code></pre><p>在<code>非严格模式</code>中,这样的代码只会<code>静默失败</code>,这样可能会导致<code>用户</code>误以为<code>删除</code>操作成功了.</p><hr><blockquote><p>尝试修改一个不可修改的变量</p></blockquote><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-literal">NaN</span> = <span class="hljs-number">111</span>; <span class="hljs-comment">// 抛出TypeError错误</span>
  <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#&lt;Window&gt;'</span>
})()
</code></pre><p>在<code>非严格模式</code>中,这样的代码只会<code>静默失败</code>,这样可能会导致<code>用户</code>误以为<code>修改</code>操作成功了.</p><hr><blockquote><p>尝试修改一个不可配置的属性</p></blockquote><p>任何在<code>正常模式</code>下引起<code>静默失败</code>的赋值操作 (给<code>不可写属性</code>赋值, 给只读属性(<code>getter-only</code>)赋值, 给<code>不可扩展对象</code>(<code>non-extensible object</code>)的新属性赋值) 都会抛出异常:</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;
  <span class="hljs-comment">// 给不可写属性赋值</span>
  <span class="hljs-keyword">const</span> obj1 = {};
  <span class="hljs-built_in">Object</span>.defineProperty(obj1, <span class="hljs-string">"x"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> });
  obj1.x = <span class="hljs-number">9</span>; <span class="hljs-comment">// 抛出TypeError错误</span>
  <span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property 'x' of object '#&lt;Object&gt;'</span>

  <span class="hljs-comment">// 给只读属性赋值</span>
  <span class="hljs-keyword">const</span> obj2 = { <span class="hljs-keyword">get</span> x() { <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>; } };
  obj2.x = <span class="hljs-number">5</span>; <span class="hljs-comment">// 抛出TypeError错误</span>
  <span class="hljs-comment">// Uncaught TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter</span>

  <span class="hljs-comment">// 给不可扩展对象的新属性赋值</span>
  <span class="hljs-keyword">const</span> fixed = {};
  <span class="hljs-built_in">Object</span>.preventExtensions(fixed);
  fixed.newProp = <span class="hljs-string">"ohai"</span>; <span class="hljs-comment">// 抛出TypeError错误</span>
  <span class="hljs-comment">// Uncaught TypeError: Cannot add property newProp, object is not extensible</span>
})()
</code></pre><p>在<code>非严格模式</code>中,这样的代码只会<code>静默失败</code>,这样可能会导致<code>用户</code>误以为<code>设置</code>操作成功了.</p><hr><blockquote><p>严格模式要求函数的参数名唯一</p></blockquote><p>在<code>正常模式</code>下, 最后一个<code>重名参数</code>名会掩盖之前的<code>重名参数</code>.</p><p>之前的参数仍然可以通过 <code>arguments[i]</code> 来访问, 还不是完全无法访问.</p><p>然而, 这种隐藏<code>毫无意义</code>而且可能是<code>意料之外</code>的 (比如它可能本来是打错了), 所以在<code>严格模式</code>下重名参数被认为是<code>语法错误</code>:</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>
  <span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">a, a, c</span>) =&gt;</span> { <span class="hljs-comment">// !!! 语法错误</span>
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-keyword">return</span> a + a + c; <span class="hljs-comment">// 代码运行到这里会出错</span>
  }
})()
</code></pre><hr><blockquote><p><code>ECMAScript 6</code>中的严格模式禁止设置<code>primitive</code>值的属性.</p></blockquote><p>不采用严格模式,设置属性将会简单忽略(<code>no-op</code>),采用<code>严格模式</code>,将抛出<code>TypeError</code>错误</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-string">'use strict'</span>;

  <span class="hljs-literal">false</span>.true = <span class="hljs-string">""</span>;              <span class="hljs-comment">// Uncaught TypeError: Cannot create property 'true' on boolean 'false'</span>
  (<span class="hljs-number">14</span>).sailing = <span class="hljs-string">"home"</span>;        <span class="hljs-comment">// Uncaught TypeError: Cannot create property 'sailing' on number '14'</span>
  <span class="hljs-string">"with"</span>.you = <span class="hljs-string">"far away"</span>;      <span class="hljs-comment">// Uncaught TypeError: Cannot create property 'you' on string 'with'</span>

})();
</code></pre><hr><h3 id="es6改动说明"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" target="_blank" rel="noopener">ES6改动说明</a> <a class="markdownIt-Anchor" href="#es6改动说明">#</a></h3><p><code>ES2016</code> 做了一点修改，规定只要<code>函数参数</code>使用了<code>默认值</code>、<code>解构赋值</code>、或者<code>扩展运算符</code>，那么函数内部就不能显式设定为<code>严格模式</code>，否则会报错。</p><pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">const</span> doSomething = <span class="hljs-function">(<span class="hljs-params">a, b = a</span>) =&gt;</span> {
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-comment">// code</span>
    <span class="hljs-comment">// Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list</span>
  }

  <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">const</span> doSomething = <span class="hljs-function">(<span class="hljs-params">{a, b}</span>) =&gt;</span> {
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-comment">// code</span>
    <span class="hljs-comment">// Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list</span>
  };

  <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">const</span> doSomething = <span class="hljs-function">(<span class="hljs-params">...a</span>) =&gt;</span> {
    <span class="hljs-string">'use strict'</span>;
    <span class="hljs-comment">// code</span>
    <span class="hljs-comment">// Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list</span>
  };

  <span class="hljs-keyword">const</span> obj = {
    <span class="hljs-comment">// 报错</span>
    doSomething({a, b}) {
      <span class="hljs-string">'use strict'</span>;
      <span class="hljs-comment">// code</span>
      <span class="hljs-comment">// Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list</span>
    }
  };
})()
</code></pre><p>这样规定的原因是，函数内部的<code>严格模式</code>，同时适用于<code>函数体</code>和<code>函数参数</code>。</p><p>但是，<code>函数</code>执行的时候，先执行<code>函数参数</code>，然后再执行<code>函数体</code>。</p><p>这样就有一个不合理的地方，只有从<code>函数体</code>之中，才能知道参数是否应该以<code>严格模式</code>执行，但是参数却应该先于<code>函数体</code>执行。</p><hr><h2 id="语义差异">语义差异 <a class="markdownIt-Anchor" href="#语义差异">#</a></h2><p>这些差异都是一些<code>微小</code>的<code>差异</code>。</p><p>有可能<code>单元测试</code>没办法捕获这种微小的<code>差异</code>。你很有必要去小心地审查你的代码，来确保这些<code>差异</code>不会影响你代码的语义。</p><p>幸运的是，这种小心地<code>代码审查</code>可以很大程度上避免。</p><hr><h3 id="函数调用中的this">函数调用中的this <a class="markdownIt-Anchor" href="#函数调用中的this">#</a></h3><p>在普通的函数调用<code>f()</code>中,<code>this</code>的值会指向<code>全局对象</code>.在<code>严格模式</code>中,<code>this</code>的值会指向<code>undefined</code>.</p><p>当函数通过<code>call</code>和<code>apply</code>调用时,如果传入的<code>thisValue</code>参数是一个<code>null</code>和<code>undefined</code>除外的<code>原始值</code>(<code>字符串</code>,<code>数字</code>,<code>布尔值</code>),则<code>this</code>的值会成为那个<code>原始值</code>对应的<code>包装对象</code>,如果<code>thisValue</code>参数的值是<code>undefined</code>或<code>null</code>,则<code>this</code>的值会指向<code>全局对象</code>.</p><p>在<code>严格模式</code>中,<code>this</code>的值就是<code>thisValue</code>参数的值,没有任何类型转换.</p><hr><h3 id="arguments对象属性更新">arguments对象属性更新 <a class="markdownIt-Anchor" href="#arguments对象属性更新">#</a></h3><p><code>arguments</code>对象属性不与对应的<code>形参变量</code>同步更新</p><p>在<code>非严格模式</code>中,修改<code>arguments</code>对象中某个<code>索引属性</code>的值,和这个属性对应的<code>形参变量</code>的值也会同时变化,反之亦然.</p><p>这会让<code>JavaScript</code>的<code>代码混淆引擎</code>让代码变得更<code>难读</code>和<code>理解</code>。</p><p>在<code>严格模式</code>中<code>arguments</code> 对象会以<code>形参变量</code>的拷贝的形式被<code>创建</code>和<code>初始化</code>，因此 <code>arguments</code> 对象的<code>改变</code>不会影响<code>形参</code>。</p><hr><h3 id="eval相关的区别">eval相关的区别 <a class="markdownIt-Anchor" href="#eval相关的区别">#</a></h3><p>在<code>严格模式</code>中,<code>eval</code>不会在当前的<code>作用域</code>内创建新的<code>变量</code>.另外,传入<code>eval</code>的<code>字符串参数</code>也会按照<code>严格模式</code>来解析.</p><p>你需要<code>全面测试</code>来确保没有代码受到影响。另外，如果你并不是为了解决一个非常实际的<code>解决方案</code>中，尽量不要使用<code>eval</code>。</p><hr></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../chapters07/arrow-function.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="../chapters07/function-parameter-improvement.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.16</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../chapters01/index.html">第一章 ECMAScript 6 简介</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters01/base-js.html">js基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/base-es.html">es基础前置知识</a></li><li class="chapter-item"><a href="../chapters01/Babel.html">通过Babel使用ES6</a></li><li class="chapter-item"><a href="../chapters01/Traceur.html">通过Traceur使用ES6</a></li><li class="chapter-item"><a href="../chapters01/stage-00.html">Strawman 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-01.html">Proposal 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-02.html">Draft 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/active-proposals.html">Candidate 阶段的 proposals</a></li><li class="chapter-item"><a href="../chapters01/stage-04.html">Finished 阶段的 proposals</a></li></ul><li class="chapter-item"><a href="../chapters02/index.html">第二章 let和const命令</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters02/base.html">前置知识了解</a></li><li class="chapter-item"><a href="../chapters02/let.html">let 命令</a></li><li class="chapter-item"><a href="../chapters02/const.html">const 命令</a></li><li class="chapter-item"><a href="../chapters02/statement-details.html">语句进阶说明</a></li></ul><li class="chapter-item"><a href="../chapters03/index.html">第三章 变量的解构赋值</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters03/base.html">基础数据结构</a></li><li class="chapter-item"><a href="../chapters03/complex.html">复杂数据结构</a></li><li class="chapter-item"><a href="../chapters03/parentheses.html">圆括号问题</a></li><li class="chapter-item"><a href="../chapters03/use.html">用途</a></li></ul><li class="chapter-item"><a href="../chapters04/index.html">第四章 字符串的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters04/unicode.html">字符的 Unicode 表示法</a></li><li class="chapter-item"><a href="../chapters04/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters04/template-string.html">模板字符串</a></li><li class="chapter-item"><a href="../chapters04/string-Iterator.html">字符串的遍历器接口</a></li><li class="chapter-item"><a href="../chapters04/tag-template.html">标签模板</a></li></ul><li class="chapter-item"><a href="../chapters05/index.html">第五章 正则的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters05/constructor.html">RegExp 构造函数</a></li><li class="chapter-item"><a href="../chapters05/base.html">RegExp 基础使用</a></li><li class="chapter-item"><a href="../chapters05/prototype-attribute.html">RegExp 原型属性</a></li><li class="chapter-item"><a href="../chapters05/modifier.html">RegExp 修饰符</a></li><li class="chapter-item"><a href="../chapters05/assert.html">RegExp 断言</a></li><li class="chapter-item"><a href="../chapters05/string-with-regExp.html">String中正则相关方法</a></li><li class="chapter-item"><a href="../chapters05/named-group-matching.html">具名组匹配</a></li><li class="chapter-item"><a href="../chapters05/unicode-attribute-class.html">Unicode 属性类</a></li></ul><li class="chapter-item"><a href="../chapters06/index.html">第六章 数值的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters06/base-notation.html">Number 进制表示法</a></li><li class="chapter-item"><a href="../chapters06/prototype-attribute.html">Number 原型属性</a></li><li class="chapter-item"><a href="../chapters06/base-function-extend.html">Number 对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/prototype-function-extend.html">Number 原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters06/math-extension.html">math 对象扩展</a></li><li class="chapter-item"><a href="../chapters06/exponent-operator.html">指数运算符</a></li></ul><li class="chapter-item"><a href="../chapters07/index.html">第七章 函数的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item"><a href="../chapters07/arrow-function.html">箭头函数</a></li><li class="chapter-item chapter-item-current"><a href="../chapters07/strict-mode.html">严格模式</a></li><li class="chapter-item"><a href="../chapters07/function-parameter-improvement.html">函数参数改进</a></li><li class="chapter-item"><a href="../chapters07/the-name-attribute-of-the-function.html">函数的name属性</a></li><li class="chapter-item"><a href="../chapters07/tail-call-optimization.html">尾调用优化</a></li></ul><li class="chapter-item"><a href="../chapters08/index.html">第八章 数组的扩展</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters08/extension-operator.html">扩展运算符</a></li><li class="chapter-item"><a href="../chapters08/prototype-function-extend.html">原型对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/instance-function-extend.html">实例对象方法扩展</a></li><li class="chapter-item"><a href="../chapters08/empty-space-processing-of-array.html">数组的空位处理</a></li><li class="chapter-item"><a href="../chapters08/pipeline-optimization-of-arrays.html">数组的管道运算优化</a></li></ul><li class="chapter-item"><a href="../chapters09/index.html">第九章 ts学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters09/history.html">ts历史</a></li><li class="chapter-item"><a href="../chapters09/advantages-and-disadvantages.html">ts优势与劣势</a></li><li class="chapter-item"><a href="../chapters09/learn-primitive-type.html">基础类型学习</a></li><li class="chapter-item"><a href="../chapters09/learn-derivative-type.html">衍生类型基础学习</a></li><li class="chapter-item"><a href="../chapters09/Enum.html">衍生类型之Enum</a></li><li class="chapter-item"><a href="../chapters09/interface.html">衍生类型之interface</a></li><li class="chapter-item"><a href="../chapters09/Class.html">衍生类型之Class</a></li><li class="chapter-item"><a href="../chapters09/ts-util.html">ts 高级工具用法</a></li></ul><li class="chapter-item"><a href="../chapters10/index.html">第十章 react学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters10/history.html">react历史</a></li><li class="chapter-item"><a href="../chapters10/version-management.html">react版本管理</a></li><li class="chapter-item"><a href="../chapters10/advantages-and-disadvantages.html">react优势与劣势</a></li><li class="chapter-item"><a href="../chapters10/base.html">react基础语法</a></li><li class="chapter-item"><a href="../chapters10/common-package.html">react常用组件包</a></li><li class="chapter-item"><a href="../chapters10/family-bucket.html">react全家桶</a></li><li class="chapter-item"><a href="../chapters10/ecosphere.html">react的生态圈</a></li><li class="chapter-item"><a href="../chapters10/substitute-product.html">react和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters11/index.html">第十一章 webpack学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters11/history.html">webpack历史</a></li><li class="chapter-item"><a href="../chapters11/version-management.html">webpack版本管理</a></li><li class="chapter-item"><a href="../chapters11/advantages-and-disadvantages.html">webpack优势与劣势</a></li><li class="chapter-item"><a href="../chapters11/base-config.html">webpack项目基础配置</a></li><li class="chapter-item"><a href="../chapters11/common-package.html">webpack常用组件包</a></li><li class="chapter-item"><a href="../chapters11/ecosphere.html">webpack的生态圈</a></li><li class="chapter-item"><a href="../chapters11/substitute-product.html">webpack和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters12/index.html">第十二章 微信小程序学习</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters12/history.html">微信小程序历史</a></li><li class="chapter-item"><a href="../chapters12/version-management.html">微信小程序版本管理</a></li><li class="chapter-item"><a href="../chapters12/advantages-and-disadvantages.html">微信小程序优势与劣势</a></li><li class="chapter-item"><a href="../chapters12/base.html">微信小程序基础学习</a></li><li class="chapter-item"><a href="../chapters12/common-ui-package.html">微信小程序常用UI库</a></li><li class="chapter-item"><a href="../chapters12/ecosphere.html">微信小程序的生态圈</a></li><li class="chapter-item"><a href="../chapters12/cross-platform.html">微信小程序跨平台</a></li><li class="chapter-item"><a href="../chapters12/substitute-product.html">微信小程序和替代产品类比</a></li></ul><li class="chapter-item"><a href="../chapters13/index.html">第十三章 web安全方案</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../chapters13/common-web-risks.html">常见web风险</a></li><li class="chapter-item"><a href="../chapters13/monitoring-system.html">前端监控体系</a></li><li class="chapter-item"><a href="../chapters13/performance-optimization.html">前端性能优化</a></li><li class="chapter-item"><a href="../chapters13/security-prevention-and-control.html">前端安全防控</a></li><li class="chapter-item"><a href="../chapters13/test-system.html">前端测试体系</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"chapters07/strict-mode.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E">基本说明</a></li>\n<li><a href="#%E5%BC%80%E5%90%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">开启严格模式</a>\n<ul>\n<li><a href="#%E8%84%9A%E6%9C%AC%E5%BC%80%E5%90%AF">脚本开启</a></li>\n<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%80%E5%90%AF">函数开启</a></li>\n</ul>\n</li>\n<li><a href="#%E4%BD%9C%E7%94%A8%E8%AF%B4%E6%98%8E">作用说明</a>\n<ul>\n<li><a href="#%E5%B0%86%E8%BF%87%E5%A4%B1%E9%94%99%E8%AF%AF%E8%BD%AC%E6%88%90%E5%BC%82%E5%B8%B8">将过失错误转成异常</a></li>\n<li><a href="#%E7%AE%80%E5%8C%96%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8">简化变量的使用</a></li>\n<li><a href="#%E4%B8%A5%E6%A0%BC%E6%8E%A7%E5%88%B6eval%E5%92%8Carguments">严格控制<code>eval</code>和<code>arguments</code></a></li>\n<li><a href="#%E5%AE%89%E5%85%A8%E7%9A%84javascript">&quot;安全&quot;的JavaScript</a></li>\n<li><a href="#%E4%B8%BA%E4%B9%8B%E5%90%8E%E8%A7%84%E8%8C%83%E9%93%BA%E8%B7%AF">为之后规范铺路</a></li>\n</ul>\n</li>\n<li><a href="#%E9%94%99%E8%AF%AF%E8%AF%B4%E6%98%8E">错误说明</a>\n<ul>\n<li><a href="#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF">语法错误</a></li>\n<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF">运行时错误</a></li>\n<li><a href="#es6%E6%94%B9%E5%8A%A8%E8%AF%B4%E6%98%8E">ES6改动说明</a></li>\n</ul>\n</li>\n<li><a href="#%E8%AF%AD%E4%B9%89%E5%B7%AE%E5%BC%82">语义差异</a>\n<ul>\n<li><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84this">函数调用中的this</a></li>\n<li><a href="#arguments%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%96%B0">arguments对象属性更新</a></li>\n<li><a href="#eval%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8C%BA%E5%88%AB">eval相关的区别</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>